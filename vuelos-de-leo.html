<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vuelos de Leo - Shooter Prehist√≥rico</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #000022 0%, #000044 50%, #000066 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .game-header {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 10px 20px;
            background: linear-gradient(180deg, #333366 0%, #222244 100%);
            border: 3px solid #6666aa;
            border-radius: 10px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .stat-label {
            font-size: 8px;
            color: #aaaaff;
        }

        .stat-value {
            font-size: 14px;
            color: #ffffff;
            text-shadow: 2px 2px 0 #000;
        }

        .health-bar {
            width: 150px;
            height: 20px;
            background: #330000;
            border: 2px solid #ff0000;
            border-radius: 3px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(180deg, #ff0000 0%, #aa0000 50%, #ff0000 100%);
            transition: width 0.3s;
        }

        .weapon-display {
            padding: 5px 15px;
            background: linear-gradient(180deg, #004400 0%, #002200 100%);
            border: 2px solid #00ff00;
            border-radius: 5px;
            color: #00ff00;
            font-size: 10px;
        }

        #gameCanvas {
            border: 4px solid #6666aa;
            border-radius: 5px;
            box-shadow: 0 0 30px rgba(100, 100, 255, 0.5), inset 0 0 50px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(0, 0, 50, 0.95) 0%, rgba(0, 0, 100, 0.95) 100%);
            padding: 40px;
            border: 4px solid #6666ff;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(100, 100, 255, 0.8);
        }

        .game-title {
            font-size: 28px;
            color: #ffff00;
            text-shadow: 3px 3px 0 #ff6600, 6px 6px 0 #000;
            margin-bottom: 10px;
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        .game-subtitle {
            font-size: 12px;
            color: #66aaff;
            margin-bottom: 30px;
        }

        .instructions {
            font-size: 8px;
            color: #aaaaaa;
            line-height: 2;
            margin-bottom: 30px;
            text-align: left;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
        }

        .btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            padding: 15px 30px;
            margin: 10px;
            cursor: pointer;
            border: 3px solid;
            border-radius: 5px;
            transition: all 0.2s;
            display: inline-block;
            text-decoration: none;
        }

        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px currentColor;
        }

        .btn-play {
            background: linear-gradient(180deg, #00aa00 0%, #006600 100%);
            border-color: #00ff00;
            color: #ffffff;
        }

        .btn-back {
            background: linear-gradient(180deg, #666666 0%, #444444 100%);
            border-color: #888888;
            color: #ffffff;
            font-size: 10px;
            padding: 10px 20px;
        }

        .game-over-screen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(50, 0, 0, 0.95) 0%, rgba(100, 0, 0, 0.95) 100%);
            padding: 40px;
            border: 4px solid #ff0000;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.8);
        }

        .victory-screen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: linear-gradient(180deg, rgba(0, 50, 0, 0.95) 0%, rgba(0, 100, 0, 0.95) 100%);
            padding: 40px;
            border: 4px solid #00ff00;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.8);
        }

        .screen-title {
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #000;
        }

        .final-score {
            font-size: 16px;
            color: #ffff00;
            margin-bottom: 30px;
        }

        .hidden {
            display: none !important;
        }

        .paused-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #ffff00;
            text-shadow: 4px 4px 0 #000;
            z-index: 50;
            animation: pauseBlink 0.5s ease-in-out infinite alternate;
        }

        @keyframes pauseBlink {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }

        .level-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #00ffff;
            text-shadow: 3px 3px 0 #000;
            z-index: 40;
            display: none;
            animation: levelPop 0.5s ease-out;
        }

        @keyframes levelPop {
            from { transform: translate(-50%, -50%) scale(2); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="game-header">
            <div class="stat">
                <span class="stat-label">PUNTOS</span>
                <span class="stat-value" id="scoreDisplay">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">VIDA</span>
                <div class="health-bar">
                    <div class="health-fill" id="healthBar" style="width: 100%"></div>
                </div>
            </div>
            <div class="stat">
                <span class="stat-label">ARMA</span>
                <div class="weapon-display" id="weaponDisplay">AMETRALLADORA</div>
            </div>
            <div class="stat">
                <span class="stat-label">NIVEL</span>
                <span class="stat-value" id="levelDisplay">1</span>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="gameCanvas" width="600" height="700"></canvas>

            <div class="start-screen" id="startScreen">
                <h1 class="game-title">VUELOS DE LEO</h1>
                <p class="game-subtitle">‚öîÔ∏è SHOOTER PREHIST√ìRICO ‚öîÔ∏è</p>

                <div class="instructions">
                    <p>üéÆ CONTROLES:</p>
                    <p>‚Üê ‚Üí ‚Üë ‚Üì : MOVER AVI√ìN</p>
                    <p>ESPACIO : DISPARAR</p>
                    <p>P : PAUSAR</p>
                    <br>
                    <p>üéØ 7 NIVELES DE ACCI√ìN:</p>
                    <p>DESTRUYE PTEROSAURIOS</p>
                    <p>RECOGE HUEVOS = VIDA</p>
                    <p>9 ARMAS DIFERENTES</p>
                    <p>BOSS FINAL: MEGA QUETZALCOATLUS</p>
                </div>

                <button class="btn btn-play" onclick="startGame()">‚ñ∂ DESPEGAR</button>
                <br><br>
                <a href="juegos.html" class="btn btn-back">‚Üê VOLVER</a>
            </div>

            <div class="game-over-screen" id="gameOverScreen">
                <h2 class="screen-title" style="color: #ff0000;">GAME OVER</h2>
                <p style="color: #ff6666; font-size: 10px; margin-bottom: 20px;">TU AVI√ìN HA SIDO DESTRUIDO</p>
                <p class="final-score">PUNTUACI√ìN: <span id="finalScore">0</span></p>
                <p style="color: #aaaaaa; font-size: 10px; margin-bottom: 20px;">PTEROSAURIOS DERROTADOS: <span id="killCount">0</span></p>
                <button class="btn btn-play" onclick="startGame()">REINTENTAR</button>
                <br><br>
                <a href="juegos.html" class="btn btn-back">‚Üê VOLVER</a>
            </div>

            <div class="victory-screen" id="victoryScreen">
                <h2 class="screen-title" style="color: #00ff00;">¬°VICTORIA!</h2>
                <p style="color: #66ff66; font-size: 10px; margin-bottom: 20px;">HAS DOMINADO LOS CIELOS</p>
                <p class="final-score">PUNTUACI√ìN: <span id="victoryScore">0</span></p>
                <p style="color: #aaaaaa; font-size: 10px; margin-bottom: 20px;">PTEROSAURIOS DERROTADOS: <span id="victoryKills">0</span></p>
                <button class="btn btn-play" onclick="startGame()">JUGAR DE NUEVO</button>
                <br><br>
                <a href="juegos.html" class="btn btn-back">‚Üê VOLVER</a>
            </div>

            <div class="paused-overlay" id="pausedOverlay">PAUSA</div>
            <div class="level-display" id="levelPopup"></div>
        </div>
    </div>

    <script>
        // ===== CONFIGURACI√ìN DEL JUEGO =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Estado del juego
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let level = 1;
        let killCount = 0;
        let difficultyMultiplier = 1;

        // Jugador
        let player = {
            x: 300,
            y: 600,
            width: 50,
            height: 60,
            speed: 6,
            health: 100,
            maxHealth: 100,
            weapon: 'machinegun',
            weaponLevel: 1,
            invulnerable: false,
            invulnerableTime: 0
        };

        // Arrays del juego
        let bullets = [];
        let enemies = [];
        let powerups = [];
        let particles = [];
        let explosions = [];
        let clouds = [];

        // Controles
        let keys = {};

        // Timing
        let lastShot = 0;
        let shootDelay = 150;
        let lastEnemySpawn = 0;
        let enemySpawnDelay = 1500;
        let lastPowerupSpawn = 0;
        let powerupSpawnDelay = 8000;

        // Definici√≥n de armas
        const weapons = {
            machinegun: { name: 'AMETRALLADORA', delay: 150, damage: 10, color: '#ffff00', sound: 'shoot' },
            double: { name: 'DOBLE', delay: 150, damage: 10, color: '#00ff00', sound: 'shoot' },
            spread: { name: 'DISPERSI√ìN', delay: 200, damage: 8, color: '#00ffff', sound: 'shoot' },
            laser: { name: 'L√ÅSER', delay: 100, damage: 15, color: '#ff00ff', sound: 'laser' },
            missile: { name: 'MISILES', delay: 400, damage: 30, color: '#ff6600', sound: 'missile' },
            plasma: { name: 'PLASMA', delay: 120, damage: 20, color: '#00ffaa', sound: 'laser' },
            flame: { name: 'LANZALLAMAS', delay: 50, damage: 5, color: '#ff3300', sound: 'shoot' },
            lightning: { name: 'RAYO', delay: 300, damage: 25, color: '#aaaaff', sound: 'laser' },
            bomb: { name: 'BOMBAS', delay: 600, damage: 80, color: '#ff0000', sound: 'missile' }
        };

        // Configuraci√≥n de los 7 niveles
        const levelConfig = {
            1: { name: 'CIELOS TRANQUILOS', kills: 8, spawnDelay: 2000, types: ['pteranodon', 'dimorphodon'], multiplier: 1.0 },
            2: { name: 'ZONA DE CAZA', kills: 12, spawnDelay: 1800, types: ['pteranodon', 'dimorphodon', 'rhamphorhynchus'], multiplier: 1.15 },
            3: { name: 'TERRITORIO HOSTIL', kills: 15, spawnDelay: 1500, types: ['pteranodon', 'dimorphodon', 'rhamphorhynchus', 'anhanguera'], multiplier: 1.3 },
            4: { name: 'NIDO DE GIGANTES', kills: 18, spawnDelay: 1300, types: ['dimorphodon', 'rhamphorhynchus', 'anhanguera', 'quetzalcoatlus'], multiplier: 1.5 },
            5: { name: 'TORMENTA PREHIST√ìRICA', kills: 20, spawnDelay: 1100, types: ['pteranodon', 'dimorphodon', 'rhamphorhynchus', 'anhanguera', 'quetzalcoatlus'], multiplier: 1.7 },
            6: { name: 'INFIERNO JUR√ÅSICO', kills: 25, spawnDelay: 900, types: ['rhamphorhynchus', 'anhanguera', 'quetzalcoatlus'], multiplier: 2.0 },
            7: { name: 'REY DE LOS CIELOS', kills: 1, spawnDelay: 5000, types: ['boss'], multiplier: 2.5, boss: true }
        };

        let levelKills = 0; // Kills en el nivel actual
        let boss = null; // Boss del nivel 7

        // ===== SISTEMA DE AUDIO =====
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx || audioCtx.state !== 'running') return;

            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                switch(type) {
                    case 'shoot':
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
                        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.1);
                        break;

                    case 'laser':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.15);
                        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.15);
                        break;

                    case 'missile':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.3);
                        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.3);
                        break;

                    case 'explosion':
                        const noise = audioCtx.createBufferSource();
                        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
                        const output = noiseBuffer.getChannelData(0);
                        for (let i = 0; i < noiseBuffer.length; i++) {
                            output[i] = Math.random() * 2 - 1;
                        }
                        noise.buffer = noiseBuffer;
                        const noiseGain = audioCtx.createGain();
                        noiseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                        const filter = audioCtx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(1000, audioCtx.currentTime);
                        filter.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
                        noise.connect(filter);
                        filter.connect(noiseGain);
                        noiseGain.connect(audioCtx.destination);
                        noise.start();
                        break;

                    case 'hit':
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.1);
                        break;

                    case 'powerup':
                        const notes = [523, 659, 784, 1047];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                const o = audioCtx.createOscillator();
                                const g = audioCtx.createGain();
                                o.type = 'sine';
                                o.frequency.value = freq;
                                g.gain.setValueAtTime(0.15, audioCtx.currentTime);
                                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                                o.connect(g);
                                g.connect(audioCtx.destination);
                                o.start();
                                o.stop(audioCtx.currentTime + 0.1);
                            }, i * 50);
                        });
                        break;

                    case 'damage':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.2);
                        break;

                    case 'gameover':
                        const goNotes = [400, 350, 300, 250, 200];
                        goNotes.forEach((freq, i) => {
                            setTimeout(() => {
                                const o = audioCtx.createOscillator();
                                const g = audioCtx.createGain();
                                o.type = 'sawtooth';
                                o.frequency.value = freq;
                                g.gain.setValueAtTime(0.2, audioCtx.currentTime);
                                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                                o.connect(g);
                                g.connect(audioCtx.destination);
                                o.start();
                                o.stop(audioCtx.currentTime + 0.3);
                            }, i * 200);
                        });
                        break;

                    case 'levelup':
                        const luNotes = [523, 659, 784, 1047, 1319];
                        luNotes.forEach((freq, i) => {
                            setTimeout(() => {
                                const o = audioCtx.createOscillator();
                                const g = audioCtx.createGain();
                                o.type = 'square';
                                o.frequency.value = freq;
                                g.gain.setValueAtTime(0.15, audioCtx.currentTime);
                                g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                                o.connect(g);
                                g.connect(audioCtx.destination);
                                o.start();
                                o.stop(audioCtx.currentTime + 0.15);
                            }, i * 80);
                        });
                        break;
                }
            } catch(e) {
                console.log('Audio error:', e);
            }
        }

        // ===== TIPOS DE PTEROSAURIOS =====
        const pterosaurTypes = {
            pteranodon: {
                name: 'Pteranodon',
                width: 60,
                height: 50,
                health: 20,
                speed: 2,
                points: 100,
                color: '#8B4513',
                pattern: 'straight'
            },
            dimorphodon: {
                name: 'Dimorphodon',
                width: 40,
                height: 35,
                health: 10,
                speed: 4,
                points: 150,
                color: '#228B22',
                pattern: 'zigzag'
            },
            quetzalcoatlus: {
                name: 'Quetzalcoatlus',
                width: 90,
                height: 70,
                health: 60,
                speed: 1.5,
                points: 300,
                color: '#4B0082',
                pattern: 'straight'
            },
            rhamphorhynchus: {
                name: 'Rhamphorhynchus',
                width: 50,
                height: 45,
                health: 25,
                speed: 3,
                points: 200,
                color: '#B22222',
                pattern: 'dive'
            },
            anhanguera: {
                name: 'Anhanguera',
                width: 55,
                height: 48,
                health: 30,
                speed: 2.5,
                points: 250,
                color: '#FF8C00',
                pattern: 'swoop'
            },
            boss: {
                name: 'MEGA QUETZALCOATLUS',
                width: 180,
                height: 140,
                health: 500,
                speed: 1,
                points: 5000,
                color: '#8B0000',
                pattern: 'boss'
            }
        };

        // ===== DIBUJAR AVI√ìN =====
        function drawPlayer() {
            ctx.save();

            // Parpadeo si invulnerable
            if (player.invulnerable && Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            const x = player.x;
            const y = player.y;

            // Estela de movimiento
            ctx.fillStyle = 'rgba(100, 150, 255, 0.1)';
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.ellipse(x, y + i * 15, 15 - i * 3, 8, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Llamas del motor mejoradas
            const flameHeight = 20 + Math.random() * 15;
            // Llama exterior
            ctx.fillStyle = '#ff3300';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(x - 12, y + 28);
            ctx.quadraticCurveTo(x - 8, y + 35, x, y + 28 + flameHeight);
            ctx.quadraticCurveTo(x + 8, y + 35, x + 12, y + 28);
            ctx.fill();

            // Llama media
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.moveTo(x - 8, y + 28);
            ctx.quadraticCurveTo(x - 4, y + 32, x, y + 28 + flameHeight * 0.75);
            ctx.quadraticCurveTo(x + 4, y + 32, x + 8, y + 28);
            ctx.fill();

            // Llama interior
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(x - 4, y + 28);
            ctx.lineTo(x, y + 28 + flameHeight * 0.5);
            ctx.lineTo(x + 4, y + 28);
            ctx.fill();

            // Centro blanco
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(x - 2, y + 28);
            ctx.lineTo(x, y + 28 + flameHeight * 0.3);
            ctx.lineTo(x + 2, y + 28);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Sombra del avi√≥n
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(x + 3, y + 35, 25, 8, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Alas principales con degradado
            const wingGrad = ctx.createLinearGradient(x - 40, y, x + 40, y);
            wingGrad.addColorStop(0, '#2255aa');
            wingGrad.addColorStop(0.3, '#4488dd');
            wingGrad.addColorStop(0.5, '#66aaff');
            wingGrad.addColorStop(0.7, '#4488dd');
            wingGrad.addColorStop(1, '#2255aa');
            ctx.fillStyle = wingGrad;

            // Ala izquierda
            ctx.beginPath();
            ctx.moveTo(x - 12, y - 2);
            ctx.lineTo(x - 45, y + 12);
            ctx.lineTo(x - 42, y + 18);
            ctx.lineTo(x - 38, y + 22);
            ctx.lineTo(x - 10, y + 12);
            ctx.closePath();
            ctx.fill();

            // Ala derecha
            ctx.beginPath();
            ctx.moveTo(x + 12, y - 2);
            ctx.lineTo(x + 45, y + 12);
            ctx.lineTo(x + 42, y + 18);
            ctx.lineTo(x + 38, y + 22);
            ctx.lineTo(x + 10, y + 12);
            ctx.closePath();
            ctx.fill();

            // Detalles de alas (rayas)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 20, y + 5);
            ctx.lineTo(x - 35, y + 15);
            ctx.moveTo(x + 20, y + 5);
            ctx.lineTo(x + 35, y + 15);
            ctx.stroke();

            // Cuerpo principal con degradado met√°lico
            const bodyGrad = ctx.createLinearGradient(x - 15, y, x + 15, y);
            bodyGrad.addColorStop(0, '#2244aa');
            bodyGrad.addColorStop(0.2, '#4477dd');
            bodyGrad.addColorStop(0.5, '#5588ee');
            bodyGrad.addColorStop(0.8, '#4477dd');
            bodyGrad.addColorStop(1, '#2244aa');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(x, y - 35);
            ctx.lineTo(x + 14, y + 8);
            ctx.lineTo(x + 12, y + 28);
            ctx.lineTo(x - 12, y + 28);
            ctx.lineTo(x - 14, y + 8);
            ctx.closePath();
            ctx.fill();

            // Borde del fuselaje
            ctx.strokeStyle = '#aaccff';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Cola mejorada
            ctx.fillStyle = '#1a3377';
            ctx.beginPath();
            ctx.moveTo(x - 6, y + 22);
            ctx.lineTo(x - 18, y + 35);
            ctx.lineTo(x + 18, y + 35);
            ctx.lineTo(x + 6, y + 22);
            ctx.closePath();
            ctx.fill();

            // Aleta vertical
            ctx.fillStyle = '#2244aa';
            ctx.beginPath();
            ctx.moveTo(x, y + 15);
            ctx.lineTo(x - 3, y + 30);
            ctx.lineTo(x + 3, y + 30);
            ctx.closePath();
            ctx.fill();

            // Cabina con reflejo
            const cabinGrad = ctx.createRadialGradient(x - 2, y - 14, 0, x, y - 10, 12);
            cabinGrad.addColorStop(0, '#aaffff');
            cabinGrad.addColorStop(0.5, '#44dddd');
            cabinGrad.addColorStop(1, '#227777');
            ctx.fillStyle = cabinGrad;
            ctx.beginPath();
            ctx.ellipse(x, y - 10, 7, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Reflejo en cabina
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(x - 2, y - 14, 3, 5, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Marco de cabina
            ctx.strokeStyle = '#334466';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(x, y - 10, 7, 12, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Punta del avi√≥n
            ctx.fillStyle = '#ff4400';
            ctx.beginPath();
            ctx.moveTo(x, y - 35);
            ctx.lineTo(x - 4, y - 28);
            ctx.lineTo(x + 4, y - 28);
            ctx.closePath();
            ctx.fill();

            // Ca√±ones mejorados
            ctx.fillStyle = '#222222';
            ctx.fillRect(x - 22, y + 2, 6, 18);
            ctx.fillRect(x + 16, y + 2, 6, 18);

            // Destellos en ca√±ones
            ctx.fillStyle = '#666666';
            ctx.fillRect(x - 21, y + 3, 2, 16);
            ctx.fillRect(x + 17, y + 3, 2, 16);

            // Bocas de ca√±√≥n
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.arc(x - 19, y + 2, 3, 0, Math.PI * 2);
            ctx.arc(x + 19, y + 2, 3, 0, Math.PI * 2);
            ctx.fill();

            // L√≠nea decorativa central
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - 30);
            ctx.lineTo(x, y + 20);
            ctx.stroke();

            // Marcas en las alas
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x - 30, y + 12, 4, 0, Math.PI * 2);
            ctx.arc(x + 30, y + 12, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // ===== DIBUJAR PTEROSAURIO =====
        function drawPterosaurus(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);

            const type = pterosaurTypes[enemy.type];
            const wingFlap = Math.sin(Date.now() / 100 + enemy.id) * 15;
            const wingRotation = Math.sin(Date.now() / 100 + enemy.id) * 0.3;

            // Sombra del pterosaurio
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(5, 35, type.width/2, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Crear degradado para las alas
            const wingGradLeft = ctx.createLinearGradient(-type.width/2, 0, -5, 0);
            wingGradLeft.addColorStop(0, shadeColor(type.color, -40));
            wingGradLeft.addColorStop(0.5, type.color);
            wingGradLeft.addColorStop(1, shadeColor(type.color, 20));

            const wingGradRight = ctx.createLinearGradient(5, 0, type.width/2, 0);
            wingGradRight.addColorStop(0, shadeColor(type.color, 20));
            wingGradRight.addColorStop(0.5, type.color);
            wingGradRight.addColorStop(1, shadeColor(type.color, -40));

            // Ala izquierda con membrana
            ctx.fillStyle = wingGradLeft;
            ctx.beginPath();
            ctx.moveTo(-5, -5);
            ctx.bezierCurveTo(-type.width/3, -15 + wingFlap, -type.width/2 - 5, -10 + wingFlap, -type.width/2, 5 + wingFlap);
            ctx.bezierCurveTo(-type.width/2 + 5, 12 + wingFlap/2, -type.width/3, 15, -5, 8);
            ctx.closePath();
            ctx.fill();

            // Venas del ala izquierda
            ctx.strokeStyle = shadeColor(type.color, -30);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.quadraticCurveTo(-type.width/3, 0 + wingFlap/2, -type.width/2 + 5, 5 + wingFlap);
            ctx.moveTo(-10, -2);
            ctx.quadraticCurveTo(-type.width/4, -8 + wingFlap/2, -type.width/2 + 10, -5 + wingFlap);
            ctx.stroke();

            // Ala derecha con membrana
            ctx.fillStyle = wingGradRight;
            ctx.beginPath();
            ctx.moveTo(5, -5);
            ctx.bezierCurveTo(type.width/3, -15 + wingFlap, type.width/2 + 5, -10 + wingFlap, type.width/2, 5 + wingFlap);
            ctx.bezierCurveTo(type.width/2 - 5, 12 + wingFlap/2, type.width/3, 15, 5, 8);
            ctx.closePath();
            ctx.fill();

            // Venas del ala derecha
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.quadraticCurveTo(type.width/3, 0 + wingFlap/2, type.width/2 - 5, 5 + wingFlap);
            ctx.moveTo(10, -2);
            ctx.quadraticCurveTo(type.width/4, -8 + wingFlap/2, type.width/2 - 10, -5 + wingFlap);
            ctx.stroke();

            // Cuerpo con degradado
            const bodyGrad = ctx.createRadialGradient(0, 5, 0, 0, 5, 18);
            bodyGrad.addColorStop(0, shadeColor(type.color, 30));
            bodyGrad.addColorStop(0.5, type.color);
            bodyGrad.addColorStop(1, shadeColor(type.color, -30));
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 5, 12, 18, 0, 0, Math.PI * 2);
            ctx.fill();

            // Textura del cuerpo (escamas)
            ctx.fillStyle = shadeColor(type.color, -20);
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(-3 + (i % 2) * 6, -2 + i * 4, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Cuello
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.moveTo(-6, -5);
            ctx.quadraticCurveTo(-4, -12, 0, -15);
            ctx.quadraticCurveTo(4, -12, 6, -5);
            ctx.fill();

            // Cabeza con degradado
            const headGrad = ctx.createRadialGradient(-2, -17, 0, 0, -15, 12);
            headGrad.addColorStop(0, shadeColor(type.color, 40));
            headGrad.addColorStop(1, shadeColor(type.color, -20));
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.ellipse(0, -15, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cresta (var√≠a seg√∫n tipo)
            if (enemy.type === 'pteranodon' || enemy.type === 'quetzalcoatlus') {
                const crestaGrad = ctx.createLinearGradient(-20, -25, 0, -15);
                crestaGrad.addColorStop(0, shadeColor(type.color, -40));
                crestaGrad.addColorStop(1, type.color);
                ctx.fillStyle = crestaGrad;
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.quadraticCurveTo(-10, -28, -25, -28);
                ctx.quadraticCurveTo(-15, -22, 0, -15);
                ctx.fill();
                // Borde de la cresta
                ctx.strokeStyle = shadeColor(type.color, 30);
                ctx.lineWidth = 1;
                ctx.stroke();
            } else if (enemy.type === 'dimorphodon') {
                // Dimorphodon tiene cabeza m√°s grande y colores vibrantes
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.ellipse(0, -16, 9, 11, 0, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'rhamphorhynchus') {
                // Cola larga con rombo al final
                ctx.strokeStyle = type.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 23);
                ctx.quadraticCurveTo(5, 35, 0, 45);
                ctx.stroke();
                ctx.fillStyle = type.color;
                ctx.beginPath();
                ctx.moveTo(0, 42);
                ctx.lineTo(-6, 48);
                ctx.lineTo(0, 55);
                ctx.lineTo(6, 48);
                ctx.closePath();
                ctx.fill();
            }

            // Pico con degradado met√°lico
            const beakGrad = ctx.createLinearGradient(0, -15, 0, 8);
            beakGrad.addColorStop(0, '#ffdd66');
            beakGrad.addColorStop(0.5, '#ffaa22');
            beakGrad.addColorStop(1, '#cc7700');
            ctx.fillStyle = beakGrad;
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(-4, -8);
            ctx.lineTo(-2, 8);
            ctx.lineTo(0, 10);
            ctx.lineTo(2, 8);
            ctx.lineTo(4, -8);
            ctx.closePath();
            ctx.fill();

            // L√≠nea del pico
            ctx.strokeStyle = '#996600';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(0, 8);
            ctx.stroke();

            // Fosas nasales
            ctx.fillStyle = '#663300';
            ctx.beginPath();
            ctx.ellipse(-2, -6, 1, 1.5, 0, 0, Math.PI * 2);
            ctx.ellipse(2, -6, 1, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Ojos con brillo
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(-4, -18, 3.5, 0, Math.PI * 2);
            ctx.arc(4, -18, 3.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Pupilas verticales (reptil)
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.ellipse(-4, -18, 1, 2.5, 0, 0, Math.PI * 2);
            ctx.ellipse(4, -18, 1, 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Reflejo en los ojos
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(-5, -19, 1, 0, Math.PI * 2);
            ctx.arc(3, -19, 1, 0, Math.PI * 2);
            ctx.fill();

            // Patas con garras
            ctx.strokeStyle = shadeColor(type.color, -20);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-5, 20);
            ctx.lineTo(-8, 28);
            ctx.moveTo(5, 20);
            ctx.lineTo(8, 28);
            ctx.stroke();

            // Garras
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-10, 27);
            ctx.lineTo(-8, 32);
            ctx.moveTo(-8, 28);
            ctx.lineTo(-6, 33);
            ctx.moveTo(10, 27);
            ctx.lineTo(8, 32);
            ctx.moveTo(8, 28);
            ctx.lineTo(6, 33);
            ctx.stroke();

            // Barra de vida mejorada
            const healthPercent = enemy.health / (pterosaurTypes[enemy.type].health * levelConfig[level].multiplier);
            const barWidth = 40;
            ctx.fillStyle = '#220000';
            ctx.fillRect(-barWidth/2 - 1, -38, barWidth + 2, 8);

            const healthGrad = ctx.createLinearGradient(-barWidth/2, -37, -barWidth/2 + barWidth * healthPercent, -37);
            if (healthPercent > 0.5) {
                healthGrad.addColorStop(0, '#00ff00');
                healthGrad.addColorStop(1, '#00aa00');
            } else if (healthPercent > 0.25) {
                healthGrad.addColorStop(0, '#ffff00');
                healthGrad.addColorStop(1, '#ffaa00');
            } else {
                healthGrad.addColorStop(0, '#ff0000');
                healthGrad.addColorStop(1, '#aa0000');
            }
            ctx.fillStyle = healthGrad;
            ctx.fillRect(-barWidth/2, -37, barWidth * healthPercent, 6);

            // Borde de la barra
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(-barWidth/2 - 1, -38, barWidth + 2, 8);

            ctx.restore();
        }

        // Funci√≥n auxiliar para oscurecer/aclarar colores
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // ===== DIBUJAR HUEVO CON ALAS =====
        function drawHealthEgg(powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);

            const wingFlap = Math.sin(Date.now() / 80) * 20;
            const pulse = Math.sin(Date.now() / 200) * 0.1 + 1;
            const glow = Math.sin(Date.now() / 150) * 0.3 + 0.7;

            // Aura m√°gica exterior
            const auraGrad = ctx.createRadialGradient(0, 0, 15, 0, 0, 40 * pulse);
            auraGrad.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
            auraGrad.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');
            auraGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = auraGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 40 * pulse, 0, Math.PI * 2);
            ctx.fill();

            // Part√≠culas de brillo
            for (let i = 0; i < 6; i++) {
                const angle = (Date.now() / 1000 + i * Math.PI / 3) % (Math.PI * 2);
                const dist = 25 + Math.sin(Date.now() / 300 + i) * 5;
                ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Alas con plumas detalladas
            // Ala izquierda
            const wingGradL = ctx.createLinearGradient(-30, 0, -10, 0);
            wingGradL.addColorStop(0, '#ffffff');
            wingGradL.addColorStop(0.5, '#ffeedd');
            wingGradL.addColorStop(1, '#ffddcc');

            ctx.fillStyle = wingGradL;
            ctx.beginPath();
            ctx.moveTo(-8, -5);
            ctx.quadraticCurveTo(-20, -15 + wingFlap/2, -28, -5 + wingFlap/3);
            ctx.quadraticCurveTo(-30, 5 + wingFlap/3, -25, 10 + wingFlap/4);
            ctx.quadraticCurveTo(-18, 8, -8, 5);
            ctx.closePath();
            ctx.fill();

            // Plumas del ala izquierda
            ctx.strokeStyle = '#ddccbb';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-12, 0);
            ctx.quadraticCurveTo(-18, -3 + wingFlap/4, -25, 0 + wingFlap/3);
            ctx.moveTo(-14, 3);
            ctx.quadraticCurveTo(-20, 3 + wingFlap/4, -26, 6 + wingFlap/3);
            ctx.stroke();

            // Ala derecha
            const wingGradR = ctx.createLinearGradient(10, 0, 30, 0);
            wingGradR.addColorStop(0, '#ffddcc');
            wingGradR.addColorStop(0.5, '#ffeedd');
            wingGradR.addColorStop(1, '#ffffff');

            ctx.fillStyle = wingGradR;
            ctx.beginPath();
            ctx.moveTo(8, -5);
            ctx.quadraticCurveTo(20, -15 + wingFlap/2, 28, -5 + wingFlap/3);
            ctx.quadraticCurveTo(30, 5 + wingFlap/3, 25, 10 + wingFlap/4);
            ctx.quadraticCurveTo(18, 8, 8, 5);
            ctx.closePath();
            ctx.fill();

            // Plumas del ala derecha
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.quadraticCurveTo(18, -3 + wingFlap/4, 25, 0 + wingFlap/3);
            ctx.moveTo(14, 3);
            ctx.quadraticCurveTo(20, 3 + wingFlap/4, 26, 6 + wingFlap/3);
            ctx.stroke();

            // Sombra del huevo
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.beginPath();
            ctx.ellipse(2, 22, 12, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Huevo con degradado
            const eggGrad = ctx.createRadialGradient(-5, -8, 0, 0, 0, 22);
            eggGrad.addColorStop(0, '#fffef8');
            eggGrad.addColorStop(0.3, '#fff5e6');
            eggGrad.addColorStop(0.7, '#ffe4cc');
            eggGrad.addColorStop(1, '#ffd4aa');
            ctx.fillStyle = eggGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 16, 22, 0, 0, Math.PI * 2);
            ctx.fill();

            // Borde del huevo
            ctx.strokeStyle = '#ddbb99';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Manchas del huevo (estilo prehist√≥rico)
            ctx.fillStyle = 'rgba(200, 150, 100, 0.3)';
            ctx.beginPath();
            ctx.ellipse(6, 5, 4, 3, 0.3, 0, Math.PI * 2);
            ctx.ellipse(-4, 10, 3, 2, -0.2, 0, Math.PI * 2);
            ctx.ellipse(3, -8, 2, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();

            // Brillo principal
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.ellipse(-6, -10, 5, 7, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Brillo secundario
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-3, -4, 2, 3, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Cruz de vida con degradado y brillo
            const crossGrad = ctx.createLinearGradient(-10, 0, 10, 0);
            crossGrad.addColorStop(0, '#cc0000');
            crossGrad.addColorStop(0.5, '#ff4444');
            crossGrad.addColorStop(1, '#cc0000');
            ctx.fillStyle = crossGrad;
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 8 * glow;
            ctx.beginPath();
            ctx.roundRect(-4, -12, 8, 24, 2);
            ctx.roundRect(-12, -4, 24, 8, 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Centro brillante de la cruz
            ctx.fillStyle = '#ff8888';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();

            // Anillo exterior m√°gico
            ctx.strokeStyle = `rgba(255, 200, 100, ${glow * 0.6})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 28 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            ctx.stroke();

            // Texto flotante
            ctx.fillStyle = `rgba(0, 255, 0, ${glow})`;
            ctx.font = '8px Press Start 2P';
            ctx.textAlign = 'center';
            ctx.fillText('+30', 0, -30);

            ctx.restore();
        }

        // ===== DIBUJAR POWER-UP DE ARMA =====
        function drawWeaponPowerup(powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);

            const pulse = Math.sin(Date.now() / 150) * 3;
            const rotation = Date.now() / 2000;
            const glow = Math.sin(Date.now() / 200) * 0.3 + 0.7;
            const weaponColor = weapons[powerup.weaponType].color;

            // Aura del arma
            const auraGrad = ctx.createRadialGradient(0, 0, 10, 0, 0, 35 + pulse);
            auraGrad.addColorStop(0, weaponColor + '66');
            auraGrad.addColorStop(0.5, weaponColor + '33');
            auraGrad.addColorStop(1, weaponColor + '00');
            ctx.fillStyle = auraGrad;
            ctx.beginPath();
            ctx.arc(0, 0, 35 + pulse, 0, Math.PI * 2);
            ctx.fill();

            // Anillos giratorios
            ctx.strokeStyle = weaponColor + '88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 28, rotation, rotation + Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, 28, rotation + Math.PI, rotation + Math.PI * 2);
            ctx.stroke();

            // Caja con degradado met√°lico
            const boxGrad = ctx.createLinearGradient(-20, -18, 20, 18);
            boxGrad.addColorStop(0, '#2a2a5a');
            boxGrad.addColorStop(0.3, '#4a4a8a');
            boxGrad.addColorStop(0.5, '#5a5aaa');
            boxGrad.addColorStop(0.7, '#4a4a8a');
            boxGrad.addColorStop(1, '#2a2a5a');
            ctx.fillStyle = boxGrad;

            // Caja redondeada
            ctx.beginPath();
            ctx.roundRect(-20 - pulse/2, -17 - pulse/2, 40 + pulse, 34 + pulse, 5);
            ctx.fill();

            // Borde brillante
            ctx.strokeStyle = weaponColor;
            ctx.lineWidth = 3;
            ctx.shadowColor = weaponColor;
            ctx.shadowBlur = 10 * glow;
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Decoraci√≥n de esquinas
            ctx.fillStyle = weaponColor;
            ctx.beginPath();
            ctx.arc(-15, -12, 3, 0, Math.PI * 2);
            ctx.arc(15, -12, 3, 0, Math.PI * 2);
            ctx.arc(-15, 12, 3, 0, Math.PI * 2);
            ctx.arc(15, 12, 3, 0, Math.PI * 2);
            ctx.fill();

            // Icono del arma seg√∫n tipo
            ctx.fillStyle = weaponColor;
            ctx.shadowColor = weaponColor;
            ctx.shadowBlur = 8;

            switch(powerup.weaponType) {
                case 'double':
                    // Dos balas
                    ctx.fillRect(-8, -8, 4, 16);
                    ctx.fillRect(4, -8, 4, 16);
                    break;
                case 'spread':
                    // Tres l√≠neas en abanico
                    ctx.save();
                    for (let angle = -25; angle <= 25; angle += 25) {
                        ctx.rotate(angle * Math.PI / 180);
                        ctx.fillRect(-2, -12, 4, 12);
                        ctx.rotate(-angle * Math.PI / 180);
                    }
                    ctx.restore();
                    break;
                case 'laser':
                    // Rayo l√°ser
                    ctx.fillRect(-2, -12, 4, 24);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-1, -10, 2, 20);
                    break;
                case 'missile':
                    // Forma de misil
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(6, 4);
                    ctx.lineTo(4, 8);
                    ctx.lineTo(-4, 8);
                    ctx.lineTo(-6, 4);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'plasma':
                    // Esfera de plasma
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'flame':
                    // Llama
                    ctx.beginPath();
                    ctx.moveTo(-6, 10);
                    ctx.quadraticCurveTo(-8, 0, 0, -12);
                    ctx.quadraticCurveTo(8, 0, 6, 10);
                    ctx.quadraticCurveTo(0, 5, -6, 10);
                    ctx.fill();
                    break;
                case 'lightning':
                    // Rayo
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(-6, -2);
                    ctx.lineTo(0, -2);
                    ctx.lineTo(-3, 12);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(0, 0);
                    ctx.closePath();
                    ctx.fill();
                    break;
                case 'bomb':
                    // Bomba
                    ctx.beginPath();
                    ctx.arc(0, 2, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -8);
                    ctx.lineTo(0, -14);
                    ctx.stroke();
                    break;
                default:
                    // W gen√©rico
                    ctx.font = '14px Press Start 2P';
                    ctx.textAlign = 'center';
                    ctx.fillText('W', 0, 5);
            }
            ctx.shadowBlur = 0;

            // Nombre del arma
            ctx.fillStyle = '#ffffff';
            ctx.font = '6px Press Start 2P';
            ctx.textAlign = 'center';
            ctx.fillText(weapons[powerup.weaponType].name.substring(0, 8), 0, 28);

            ctx.restore();
        }

        // ===== DIBUJAR BALA =====
        function drawBullet(bullet) {
            ctx.save();
            ctx.translate(bullet.x, bullet.y);

            if (bullet.type === 'missile') {
                // Estela del misil
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(-3, 10);
                ctx.lineTo(0, 30);
                ctx.lineTo(3, 10);
                ctx.fill();

                // Cuerpo del misil con degradado met√°lico
                const missileGrad = ctx.createLinearGradient(-6, 0, 6, 0);
                missileGrad.addColorStop(0, '#aa4400');
                missileGrad.addColorStop(0.3, '#ff6600');
                missileGrad.addColorStop(0.5, '#ffaa44');
                missileGrad.addColorStop(0.7, '#ff6600');
                missileGrad.addColorStop(1, '#aa4400');
                ctx.fillStyle = missileGrad;
                ctx.beginPath();
                ctx.moveTo(0, -14);
                ctx.lineTo(6, 4);
                ctx.lineTo(5, 10);
                ctx.lineTo(-5, 10);
                ctx.lineTo(-6, 4);
                ctx.closePath();
                ctx.fill();

                // Punta roja
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(0, -14);
                ctx.lineTo(-3, -8);
                ctx.lineTo(3, -8);
                ctx.closePath();
                ctx.fill();

                // Aletas
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.moveTo(-5, 6);
                ctx.lineTo(-10, 12);
                ctx.lineTo(-5, 10);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(5, 6);
                ctx.lineTo(10, 12);
                ctx.lineTo(5, 10);
                ctx.fill();

                // Llama del misil con capas
                const flameHeight = 12 + Math.random() * 8;
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.moveTo(-4, 10);
                ctx.quadraticCurveTo(-3, 15, 0, 10 + flameHeight);
                ctx.quadraticCurveTo(3, 15, 4, 10);
                ctx.fill();

                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.moveTo(-2, 10);
                ctx.quadraticCurveTo(-1, 13, 0, 10 + flameHeight * 0.7);
                ctx.quadraticCurveTo(1, 13, 2, 10);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(-1, 10);
                ctx.lineTo(0, 10 + flameHeight * 0.4);
                ctx.lineTo(1, 10);
                ctx.fill();

            } else if (bullet.type === 'laser') {
                // Aura del l√°ser
                ctx.fillStyle = 'rgba(255, 0, 255, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Rayo principal con degradado
                const laserGrad = ctx.createLinearGradient(-3, 0, 3, 0);
                laserGrad.addColorStop(0, '#aa00aa');
                laserGrad.addColorStop(0.3, '#ff00ff');
                laserGrad.addColorStop(0.5, '#ff88ff');
                laserGrad.addColorStop(0.7, '#ff00ff');
                laserGrad.addColorStop(1, '#aa00aa');
                ctx.fillStyle = laserGrad;
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 15;
                ctx.fillRect(-3, -18, 6, 36);

                // N√∫cleo brillante
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-1, -16, 2, 32);

                // Part√≠culas de energ√≠a
                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = `rgba(255, 200, 255, ${0.5 + Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 30, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else if (bullet.type === 'plasma') {
                // Estela de plasma
                ctx.fillStyle = 'rgba(0, 255, 170, 0.2)';
                for (let i = 1; i <= 3; i++) {
                    ctx.beginPath();
                    ctx.arc(0, i * 8, 10 - i * 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Aura exterior
                const plasmaAura = ctx.createRadialGradient(0, 0, 4, 0, 0, 14);
                plasmaAura.addColorStop(0, 'rgba(0, 255, 170, 0.8)');
                plasmaAura.addColorStop(0.5, 'rgba(0, 255, 170, 0.4)');
                plasmaAura.addColorStop(1, 'rgba(0, 255, 170, 0)');
                ctx.fillStyle = plasmaAura;
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2);
                ctx.fill();

                // Esfera principal
                const plasmaGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, 10);
                plasmaGrad.addColorStop(0, '#ffffff');
                plasmaGrad.addColorStop(0.3, '#aaffee');
                plasmaGrad.addColorStop(0.6, '#00ffaa');
                plasmaGrad.addColorStop(1, '#00aa66');
                ctx.fillStyle = plasmaGrad;
                ctx.shadowColor = '#00ffaa';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fill();

                // Anillo de energ√≠a
                ctx.strokeStyle = '#88ffdd';
                ctx.lineWidth = 2;
                const ringPhase = Date.now() / 100;
                ctx.beginPath();
                ctx.arc(0, 0, 12, ringPhase, ringPhase + Math.PI);
                ctx.stroke();

            } else if (bullet.type === 'flame') {
                // Llama mejorada con capas
                const size = bullet.life ? bullet.life / 2 : 5;
                const alpha = bullet.life ? bullet.life / 20 : 1;

                // Part√≠culas de humo
                ctx.fillStyle = `rgba(100, 50, 0, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.arc((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, size * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Llama exterior
                ctx.fillStyle = `rgba(255, 50, 0, ${alpha * 0.6})`;
                ctx.beginPath();
                ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2);
                ctx.fill();

                // Llama media
                ctx.fillStyle = `rgba(255, ${100 + Math.random() * 50}, 0, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.9, 0, Math.PI * 2);
                ctx.fill();

                // N√∫cleo amarillo
                ctx.fillStyle = `rgba(255, 255, ${100 + Math.random() * 100}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Centro blanco
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fill();

            } else if (bullet.type === 'lightning') {
                // Aura el√©ctrica
                ctx.fillStyle = 'rgba(150, 150, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();

                // Rayo principal con m√∫ltiples ramas
                ctx.strokeStyle = '#ffffff';
                ctx.shadowColor = '#aaaaff';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.beginPath();
                let px = 0, py = -25;
                ctx.moveTo(px, py);
                for (let i = 0; i < 6; i++) {
                    px += (Math.random() - 0.5) * 20;
                    py += 8;
                    ctx.lineTo(px, py);

                    // Ramificaciones
                    if (Math.random() > 0.5) {
                        ctx.moveTo(px, py);
                        ctx.lineTo(px + (Math.random() - 0.5) * 20, py + 5);
                        ctx.moveTo(px, py);
                    }
                }
                ctx.lineTo((Math.random() - 0.5) * 5, 25);
                ctx.stroke();

                // Rayo secundario m√°s fino
                ctx.strokeStyle = '#aaaaff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -25);
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo((Math.random() - 0.5) * 12, -25 + i * 12);
                }
                ctx.lineTo(0, 25);
                ctx.stroke();

                // Chispas
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.arc((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 40, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else if (bullet.type === 'bomb') {
                // Sombra de la bomba
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(2, 14, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Cuerpo de la bomba con degradado met√°lico
                const bombGrad = ctx.createRadialGradient(-3, -3, 0, 0, 0, 12);
                bombGrad.addColorStop(0, '#666666');
                bombGrad.addColorStop(0.3, '#444444');
                bombGrad.addColorStop(0.7, '#222222');
                bombGrad.addColorStop(1, '#111111');
                ctx.fillStyle = bombGrad;
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fill();

                // Brillo met√°lico
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.ellipse(-4, -4, 4, 3, -0.5, 0, Math.PI * 2);
                ctx.fill();

                // Banda roja de peligro
                ctx.fillStyle = '#cc0000';
                ctx.beginPath();
                ctx.arc(0, 0, 12, -0.3, 0.3);
                ctx.arc(0, 0, 8, 0.3, -0.3, true);
                ctx.closePath();
                ctx.fill();

                // Tapa superior
                ctx.fillStyle = '#555555';
                ctx.beginPath();
                ctx.ellipse(0, -10, 5, 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Mecha
                ctx.strokeStyle = '#886644';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.quadraticCurveTo(3, -16, 0, -20);
                ctx.stroke();

                // Chispa animada
                const sparkSize = 4 + Math.random() * 4;
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(0, -20, sparkSize, 0, Math.PI * 2);
                ctx.fill();

                // Part√≠culas de la chispa
                ctx.fillStyle = '#ff6600';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc((Math.random() - 0.5) * 10, -20 + (Math.random() - 0.5) * 6, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

            } else {
                // Bala normal mejorada
                const bulletColor = bullet.color || '#ffff00';

                // Estela
                ctx.fillStyle = bulletColor + '44';
                ctx.beginPath();
                ctx.moveTo(-2, 0);
                ctx.lineTo(0, 15);
                ctx.lineTo(2, 0);
                ctx.fill();

                // Aura
                ctx.fillStyle = bulletColor + '33';
                ctx.beginPath();
                ctx.ellipse(0, 0, 6, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Bala principal con degradado
                const bulletGrad = ctx.createRadialGradient(-1, -3, 0, 0, 0, 8);
                bulletGrad.addColorStop(0, '#ffffff');
                bulletGrad.addColorStop(0.3, shadeColor(bulletColor, 30));
                bulletGrad.addColorStop(0.7, bulletColor);
                bulletGrad.addColorStop(1, shadeColor(bulletColor, -30));
                ctx.fillStyle = bulletGrad;
                ctx.shadowColor = bulletColor;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.ellipse(0, 0, 4, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // N√∫cleo brillante
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.ellipse(-1, -3, 1.5, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // ===== CREAR ENEMIGO =====
        function spawnEnemy() {
            const config = levelConfig[level];

            // Nivel 7 es boss
            if (config.boss && !boss) {
                spawnBoss();
                return;
            }

            if (config.boss) return; // No spawn normal en nivel boss

            const availableTypes = config.types;
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const pterType = pterosaurTypes[type];

            enemies.push({
                id: Date.now() + Math.random(),
                type: type,
                x: Math.random() * (canvas.width - 100) + 50,
                y: -50,
                health: pterType.health * config.multiplier,
                speed: pterType.speed * config.multiplier,
                pattern: pterType.pattern,
                phase: Math.random() * Math.PI * 2,
                targetX: player.x
            });
        }

        // ===== CREAR BOSS =====
        function spawnBoss() {
            const bossType = pterosaurTypes.boss;
            boss = {
                id: Date.now(),
                type: 'boss',
                x: canvas.width / 2,
                y: -100,
                health: bossType.health,
                maxHealth: bossType.health,
                speed: bossType.speed,
                pattern: 'boss',
                phase: 0,
                attackTimer: 0,
                state: 'entering' // entering, fighting, rage
            };
            enemies.push(boss);
        }

        // ===== DIBUJAR BOSS =====
        function drawBoss(enemy) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);

            const wingFlap = Math.sin(Date.now() / 150 + enemy.id) * 25;
            const rage = enemy.state === 'rage';
            const pulse = Math.sin(Date.now() / 200) * 0.2 + 1;
            const baseColor = rage ? '#cc0000' : '#8B0000';

            // Sombra gigante del boss
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(10, 80, 100, 30, 0, 0, Math.PI * 2);
            ctx.fill();

            // Aura de poder √©pica
            if (rage) {
                // Aura exterior pulsante
                const auraGrad = ctx.createRadialGradient(0, 0, 50, 0, 0, 150 * pulse);
                auraGrad.addColorStop(0, 'rgba(255, 0, 0, 0.3)');
                auraGrad.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
                auraGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(0, 0, 150 * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Part√≠culas de energ√≠a
                for (let i = 0; i < 8; i++) {
                    const angle = (Date.now() / 500 + i * Math.PI / 4) % (Math.PI * 2);
                    const dist = 80 + Math.sin(Date.now() / 200 + i) * 20;
                    ctx.fillStyle = `rgba(255, ${150 + Math.random() * 100}, 0, ${0.5 + Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 5 + Math.random() * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Aura normal oscura
                const auraGrad = ctx.createRadialGradient(0, 0, 30, 0, 0, 100);
                auraGrad.addColorStop(0, 'rgba(139, 0, 0, 0.2)');
                auraGrad.addColorStop(1, 'rgba(139, 0, 0, 0)');
                ctx.fillStyle = auraGrad;
                ctx.beginPath();
                ctx.arc(0, 0, 100, 0, Math.PI * 2);
                ctx.fill();
            }

            // Alas gigantes con degradado y membrana
            const wingGradL = ctx.createLinearGradient(-110, 0, -10, 0);
            wingGradL.addColorStop(0, shadeColor(baseColor, -40));
            wingGradL.addColorStop(0.3, baseColor);
            wingGradL.addColorStop(0.7, shadeColor(baseColor, 20));
            wingGradL.addColorStop(1, shadeColor(baseColor, 40));

            const wingGradR = ctx.createLinearGradient(10, 0, 110, 0);
            wingGradR.addColorStop(0, shadeColor(baseColor, 40));
            wingGradR.addColorStop(0.3, shadeColor(baseColor, 20));
            wingGradR.addColorStop(0.7, baseColor);
            wingGradR.addColorStop(1, shadeColor(baseColor, -40));

            // Ala izquierda
            ctx.fillStyle = wingGradL;
            ctx.beginPath();
            ctx.moveTo(-12, -10);
            ctx.bezierCurveTo(-50, -40 + wingFlap, -110, -35 + wingFlap, -100, 15 + wingFlap);
            ctx.bezierCurveTo(-90, 35 + wingFlap, -50, 40, -12, 15);
            ctx.closePath();
            ctx.fill();

            // Venas del ala izquierda
            ctx.strokeStyle = shadeColor(baseColor, -50);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-15, 0);
            ctx.quadraticCurveTo(-50, -10 + wingFlap/2, -90, 10 + wingFlap);
            ctx.moveTo(-20, -5);
            ctx.quadraticCurveTo(-60, -25 + wingFlap/2, -95, -5 + wingFlap);
            ctx.moveTo(-15, 8);
            ctx.quadraticCurveTo(-45, 15 + wingFlap/2, -80, 25 + wingFlap);
            ctx.stroke();

            // Ala derecha
            ctx.fillStyle = wingGradR;
            ctx.beginPath();
            ctx.moveTo(12, -10);
            ctx.bezierCurveTo(50, -40 + wingFlap, 110, -35 + wingFlap, 100, 15 + wingFlap);
            ctx.bezierCurveTo(90, 35 + wingFlap, 50, 40, 12, 15);
            ctx.closePath();
            ctx.fill();

            // Venas del ala derecha
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.quadraticCurveTo(50, -10 + wingFlap/2, 90, 10 + wingFlap);
            ctx.moveTo(20, -5);
            ctx.quadraticCurveTo(60, -25 + wingFlap/2, 95, -5 + wingFlap);
            ctx.moveTo(15, 8);
            ctx.quadraticCurveTo(45, 15 + wingFlap/2, 80, 25 + wingFlap);
            ctx.stroke();

            // Cuerpo masivo con degradado
            const bodyGrad = ctx.createRadialGradient(-5, 0, 0, 0, 10, 55);
            bodyGrad.addColorStop(0, shadeColor(baseColor, 50));
            bodyGrad.addColorStop(0.4, shadeColor(baseColor, 20));
            bodyGrad.addColorStop(0.7, baseColor);
            bodyGrad.addColorStop(1, shadeColor(baseColor, -30));
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 10, 32, 55, 0, 0, Math.PI * 2);
            ctx.fill();

            // Escamas del cuerpo
            ctx.fillStyle = shadeColor(baseColor, -25);
            for (let row = 0; row < 6; row++) {
                for (let col = -1; col <= 1; col++) {
                    ctx.beginPath();
                    ctx.arc(col * 10, -20 + row * 12, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Cuello musculoso
            const neckGrad = ctx.createLinearGradient(-15, -30, 15, -30);
            neckGrad.addColorStop(0, shadeColor(baseColor, -20));
            neckGrad.addColorStop(0.5, shadeColor(baseColor, 30));
            neckGrad.addColorStop(1, shadeColor(baseColor, -20));
            ctx.fillStyle = neckGrad;
            ctx.beginPath();
            ctx.moveTo(-15, -15);
            ctx.quadraticCurveTo(-12, -35, 0, -45);
            ctx.quadraticCurveTo(12, -35, 15, -15);
            ctx.closePath();
            ctx.fill();

            // Cabeza con degradado
            const headGrad = ctx.createRadialGradient(-5, -50, 0, 0, -45, 30);
            headGrad.addColorStop(0, shadeColor(baseColor, 50));
            headGrad.addColorStop(0.5, shadeColor(baseColor, 20));
            headGrad.addColorStop(1, shadeColor(baseColor, -20));
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.ellipse(0, -45, 22, 28, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cresta gigante con degradado
            const crestaGrad = ctx.createLinearGradient(-60, -80, 0, -50);
            crestaGrad.addColorStop(0, rage ? '#ff2200' : '#550000');
            crestaGrad.addColorStop(0.5, rage ? '#ff6600' : '#770000');
            crestaGrad.addColorStop(1, rage ? '#ffaa00' : baseColor);
            ctx.fillStyle = crestaGrad;
            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.quadraticCurveTo(-30, -85, -60, -80);
            ctx.quadraticCurveTo(-40, -70, -20, -60);
            ctx.quadraticCurveTo(-10, -55, 0, -50);
            ctx.closePath();
            ctx.fill();

            // Borde brillante de la cresta
            ctx.strokeStyle = rage ? '#ffff00' : '#aa4400';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.quadraticCurveTo(-30, -85, -60, -80);
            ctx.stroke();

            // Pico enorme con degradado met√°lico
            const beakGrad = ctx.createLinearGradient(0, -50, 0, 25);
            beakGrad.addColorStop(0, '#ffcc44');
            beakGrad.addColorStop(0.3, '#ffaa00');
            beakGrad.addColorStop(0.7, '#cc7700');
            beakGrad.addColorStop(1, '#995500');
            ctx.fillStyle = beakGrad;
            ctx.beginPath();
            ctx.moveTo(0, -45);
            ctx.lineTo(-10, -30);
            ctx.lineTo(-6, 20);
            ctx.lineTo(0, 28);
            ctx.lineTo(6, 20);
            ctx.lineTo(10, -30);
            ctx.closePath();
            ctx.fill();

            // Dientes del pico
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(-6 + i * 3, -10);
                ctx.lineTo(-5 + i * 3, -5);
                ctx.lineTo(-4 + i * 3, -10);
                ctx.fill();
            }

            // Ojos √©picos con brillo
            const eyeGlow = rage ? '#ffff00' : '#ff3300';
            ctx.fillStyle = eyeGlow;
            ctx.shadowColor = eyeGlow;
            ctx.shadowBlur = rage ? 25 : 15;
            ctx.beginPath();
            ctx.arc(-12, -50, 7, 0, Math.PI * 2);
            ctx.arc(12, -50, 7, 0, Math.PI * 2);
            ctx.fill();

            // Iris
            ctx.shadowBlur = 0;
            ctx.fillStyle = rage ? '#ff6600' : '#ff0000';
            ctx.beginPath();
            ctx.arc(-12, -50, 5, 0, Math.PI * 2);
            ctx.arc(12, -50, 5, 0, Math.PI * 2);
            ctx.fill();

            // Pupilas verticales
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-12, -50, 1.5, 4, 0, 0, Math.PI * 2);
            ctx.ellipse(12, -50, 1.5, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Reflejos en ojos
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(-14, -52, 2, 0, Math.PI * 2);
            ctx.arc(10, -52, 2, 0, Math.PI * 2);
            ctx.fill();

            // Patas musculosas con garras
            ctx.fillStyle = shadeColor(baseColor, -10);
            ctx.beginPath();
            ctx.moveTo(-15, 55);
            ctx.quadraticCurveTo(-20, 65, -18, 75);
            ctx.lineTo(-12, 75);
            ctx.quadraticCurveTo(-10, 65, -8, 55);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(15, 55);
            ctx.quadraticCurveTo(20, 65, 18, 75);
            ctx.lineTo(12, 75);
            ctx.quadraticCurveTo(10, 65, 8, 55);
            ctx.closePath();
            ctx.fill();

            // Garras afiladas
            ctx.fillStyle = '#222222';
            for (let leg = -1; leg <= 1; leg += 2) {
                for (let claw = -1; claw <= 1; claw++) {
                    ctx.beginPath();
                    ctx.moveTo(leg * 15 + claw * 4, 75);
                    ctx.lineTo(leg * 15 + claw * 6, 85);
                    ctx.lineTo(leg * 15 + claw * 2, 75);
                    ctx.fill();
                }
            }

            // Barra de vida del boss (grande y √©pica)
            const healthPercent = enemy.health / enemy.maxHealth;
            const barWidth = 160;

            // Fondo de la barra
            ctx.fillStyle = '#110000';
            ctx.fillRect(-barWidth/2 - 2, -105, barWidth + 4, 16);

            // Marco decorativo
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.strokeRect(-barWidth/2 - 2, -105, barWidth + 4, 16);

            // Degradado de vida
            const healthGrad = ctx.createLinearGradient(-barWidth/2, -103, -barWidth/2 + barWidth * healthPercent, -103);
            if (healthPercent > 0.5) {
                healthGrad.addColorStop(0, '#00ff00');
                healthGrad.addColorStop(0.5, '#44ff44');
                healthGrad.addColorStop(1, '#00aa00');
            } else if (healthPercent > 0.25) {
                healthGrad.addColorStop(0, '#ffff00');
                healthGrad.addColorStop(0.5, '#ffdd00');
                healthGrad.addColorStop(1, '#ffaa00');
            } else {
                healthGrad.addColorStop(0, '#ff0000');
                healthGrad.addColorStop(0.5, '#ff4444');
                healthGrad.addColorStop(1, '#aa0000');
            }
            ctx.fillStyle = healthGrad;
            ctx.fillRect(-barWidth/2, -103, barWidth * healthPercent, 12);

            // Brillo en la barra de vida
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(-barWidth/2, -103, barWidth * healthPercent, 4);

            // Nombre del boss con sombra
            ctx.fillStyle = '#000000';
            ctx.font = '10px Press Start 2P';
            ctx.textAlign = 'center';
            ctx.fillText('MEGA QUETZALCOATLUS', 2, -112);
            ctx.fillStyle = rage ? '#ff4400' : '#ffffff';
            ctx.fillText('MEGA QUETZALCOATLUS', 0, -114);

            // Indicador de rage
            if (rage) {
                ctx.fillStyle = '#ff0000';
                ctx.font = '8px Press Start 2P';
                ctx.fillText('¬°ENFURECIDO!', 0, -125);
            }

            ctx.restore();
        }

        // ===== CREAR POWER-UP =====
        function spawnPowerup() {
            const isHealth = Math.random() < 0.5;

            if (isHealth) {
                powerups.push({
                    type: 'health',
                    x: Math.random() * (canvas.width - 60) + 30,
                    y: -30,
                    speed: 2
                });
            } else {
                // Armas disponibles seg√∫n nivel
                let weaponTypes = ['double', 'spread'];
                if (level >= 2) weaponTypes.push('laser');
                if (level >= 3) weaponTypes.push('missile', 'plasma');
                if (level >= 4) weaponTypes.push('flame');
                if (level >= 5) weaponTypes.push('lightning');
                if (level >= 6) weaponTypes.push('bomb');

                powerups.push({
                    type: 'weapon',
                    weaponType: weaponTypes[Math.floor(Math.random() * weaponTypes.length)],
                    x: Math.random() * (canvas.width - 60) + 30,
                    y: -30,
                    speed: 2
                });
            }
        }

        // ===== DISPARAR =====
        function shoot() {
            const now = Date.now();
            const weapon = weapons[player.weapon];

            if (now - lastShot < weapon.delay) return;
            lastShot = now;

            playSound(weapon.sound);

            switch(player.weapon) {
                case 'machinegun':
                    bullets.push({
                        x: player.x,
                        y: player.y - 30,
                        vx: 0,
                        vy: -12,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'normal'
                    });
                    break;

                case 'double':
                    bullets.push({
                        x: player.x - 15,
                        y: player.y - 20,
                        vx: 0,
                        vy: -12,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'normal'
                    });
                    bullets.push({
                        x: player.x + 15,
                        y: player.y - 20,
                        vx: 0,
                        vy: -12,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'normal'
                    });
                    break;

                case 'spread':
                    for (let angle = -20; angle <= 20; angle += 20) {
                        const rad = angle * Math.PI / 180;
                        bullets.push({
                            x: player.x,
                            y: player.y - 20,
                            vx: Math.sin(rad) * 8,
                            vy: -Math.cos(rad) * 12,
                            damage: weapon.damage * player.weaponLevel,
                            color: weapon.color,
                            type: 'normal'
                        });
                    }
                    break;

                case 'laser':
                    bullets.push({
                        x: player.x,
                        y: player.y - 30,
                        vx: 0,
                        vy: -18,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'laser'
                    });
                    break;

                case 'missile':
                    bullets.push({
                        x: player.x,
                        y: player.y - 30,
                        vx: 0,
                        vy: -8,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'missile',
                        target: findNearestEnemy()
                    });
                    break;

                case 'plasma':
                    // Plasma atraviesa enemigos
                    bullets.push({
                        x: player.x,
                        y: player.y - 30,
                        vx: 0,
                        vy: -14,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'plasma',
                        piercing: true
                    });
                    break;

                case 'flame':
                    // Lanzallamas - muchas part√≠culas
                    for (let i = 0; i < 3; i++) {
                        bullets.push({
                            x: player.x + (Math.random() - 0.5) * 20,
                            y: player.y - 20,
                            vx: (Math.random() - 0.5) * 3,
                            vy: -10 - Math.random() * 4,
                            damage: weapon.damage * player.weaponLevel,
                            color: weapon.color,
                            type: 'flame',
                            life: 20
                        });
                    }
                    break;

                case 'lightning':
                    // Rayo que hace cadena
                    bullets.push({
                        x: player.x,
                        y: player.y - 30,
                        vx: 0,
                        vy: -16,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'lightning',
                        chainCount: 3
                    });
                    break;

                case 'bomb':
                    // Bomba con explosi√≥n de √°rea
                    bullets.push({
                        x: player.x,
                        y: player.y - 30,
                        vx: 0,
                        vy: -6,
                        damage: weapon.damage * player.weaponLevel,
                        color: weapon.color,
                        type: 'bomb',
                        explosionRadius: 80
                    });
                    break;
            }
        }

        function findNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;

            for (const enemy of enemies) {
                const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            }

            return nearest;
        }

        // ===== CREAR EXPLOSI√ìN =====
        function createExplosion(x, y, size) {
            // Anillo de onda expansiva
            particles.push({
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                life: 15,
                maxLife: 15,
                size: 5,
                type: 'shockwave',
                maxSize: size * 8
            });

            // Flash central brillante
            particles.push({
                x: x,
                y: y,
                vx: 0,
                vy: 0,
                life: 10,
                maxLife: 10,
                size: size * 3,
                type: 'flash',
                color: '#ffffff'
            });

            // Part√≠culas de fuego principales
            const fireColors = ['#ff0000', '#ff3300', '#ff6600', '#ff9900', '#ffcc00', '#ffff00'];
            for (let i = 0; i < 25; i++) {
                const angle = (Math.PI * 2 / 25) * i + Math.random() * 0.3;
                const speed = 3 + Math.random() * 8;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 25 + Math.random() * 15,
                    maxLife: 40,
                    size: Math.random() * size + 3,
                    type: 'fire',
                    color: fireColors[Math.floor(Math.random() * fireColors.length)]
                });
            }

            // Chispas r√°pidas
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 8 + Math.random() * 12;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 15 + Math.random() * 10,
                    maxLife: 25,
                    size: 2 + Math.random() * 2,
                    type: 'spark',
                    color: '#ffff88'
                });
            }

            // Humo oscuro
            for (let i = 0; i < 12; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1, // Humo sube
                    life: 40 + Math.random() * 20,
                    maxLife: 60,
                    size: size * 0.8 + Math.random() * size,
                    type: 'smoke',
                    color: '#333333'
                });
            }

            // Escombros
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 5;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed + 2, // Caen
                    life: 30 + Math.random() * 20,
                    maxLife: 50,
                    size: 3 + Math.random() * 4,
                    type: 'debris',
                    color: '#664422',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3
                });
            }
        }

        // ===== ACTUALIZAR NUBES =====
        function updateClouds() {
            // Crear nubes
            if (Math.random() < 0.02) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: -50,
                    width: 80 + Math.random() * 120,
                    height: 40 + Math.random() * 60,
                    speed: 0.5 + Math.random() * 1
                });
            }

            // Mover nubes
            for (let i = clouds.length - 1; i >= 0; i--) {
                clouds[i].y += clouds[i].speed;
                if (clouds[i].y > canvas.height + 100) {
                    clouds.splice(i, 1);
                }
            }
        }

        // ===== DIBUJAR FONDO =====
        function drawBackground() {
            // Cielo degradado din√°mico seg√∫n nivel
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            if (level <= 2) {
                // Cielo diurno
                gradient.addColorStop(0, '#1a1a4a');
                gradient.addColorStop(0.3, '#2a3a6a');
                gradient.addColorStop(0.6, '#4a6a9a');
                gradient.addColorStop(1, '#6a9aca');
            } else if (level <= 4) {
                // Atardecer
                gradient.addColorStop(0, '#1a0a2a');
                gradient.addColorStop(0.3, '#4a2a4a');
                gradient.addColorStop(0.6, '#8a4a3a');
                gradient.addColorStop(1, '#ca7a4a');
            } else if (level <= 6) {
                // Tormenta
                gradient.addColorStop(0, '#0a0a1a');
                gradient.addColorStop(0.3, '#1a1a3a');
                gradient.addColorStop(0.6, '#2a2a4a');
                gradient.addColorStop(1, '#3a3a5a');
            } else {
                // Boss - cielo rojo
                gradient.addColorStop(0, '#1a0000');
                gradient.addColorStop(0.3, '#3a0a0a');
                gradient.addColorStop(0.6, '#5a1a1a');
                gradient.addColorStop(1, '#2a0a0a');
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Sol/Luna seg√∫n nivel
            if (level <= 2) {
                // Sol
                ctx.fillStyle = '#ffdd44';
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(500, 80, 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else if (level >= 7) {
                // Luna roja sangrienta
                ctx.fillStyle = '#aa2222';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 40;
                ctx.beginPath();
                ctx.arc(500, 100, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1a0000';
                ctx.beginPath();
                ctx.arc(520, 90, 45, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Monta√±as de fondo (parallax lento)
            const mountainOffset = (Date.now() / 100) % canvas.width;
            ctx.fillStyle = 'rgba(30, 30, 60, 0.5)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let x = 0; x <= canvas.width + 100; x += 50) {
                const h = 150 + Math.sin((x + mountainOffset * 0.2) * 0.02) * 80;
                ctx.lineTo(x, canvas.height - h);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();

            // Monta√±as m√°s cercanas
            ctx.fillStyle = 'rgba(20, 40, 50, 0.6)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let x = 0; x <= canvas.width + 100; x += 40) {
                const h = 100 + Math.sin((x + mountainOffset * 0.5) * 0.03) * 60;
                ctx.lineTo(x, canvas.height - h);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();

            // Nubes mejoradas con sombra
            for (const cloud of clouds) {
                // Sombra de nube
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.ellipse(cloud.x + 5, cloud.y + 5, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Nube principal
                const cloudGrad = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.width/2);
                cloudGrad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                cloudGrad.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                ctx.fillStyle = cloudGrad;
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width/2, cloud.height/2, 0, 0, Math.PI * 2);
                ctx.ellipse(cloud.x - cloud.width/4, cloud.y + 5, cloud.width/3, cloud.height/2.5, 0, 0, Math.PI * 2);
                ctx.ellipse(cloud.x + cloud.width/4, cloud.y - 5, cloud.width/3, cloud.height/2.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Estrellas brillantes
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 80; i++) {
                const x = (i * 137 + 23) % canvas.width;
                const y = (i * 89 + 17) % (canvas.height / 2);
                const twinkle = Math.sin(Date.now() / 300 + i * 0.7) * 0.5 + 0.5;
                const size = (i % 3 === 0) ? 2 : 1;
                ctx.globalAlpha = twinkle * 0.8;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                // Algunas estrellas con brillo
                if (i % 7 === 0 && twinkle > 0.7) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y);
                    ctx.lineTo(x + 4, y);
                    ctx.moveTo(x, y - 4);
                    ctx.lineTo(x, y + 4);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;

            // Rayos en niveles de tormenta
            if (level >= 5 && level < 7 && Math.random() < 0.005) {
                ctx.strokeStyle = '#aaaaff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffffff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                let lx = Math.random() * canvas.width;
                let ly = 0;
                ctx.moveTo(lx, ly);
                for (let i = 0; i < 8; i++) {
                    lx += (Math.random() - 0.5) * 60;
                    ly += 40 + Math.random() * 30;
                    ctx.lineTo(lx, ly);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        // ===== ACTUALIZAR JUEGO =====
        function update() {
            if (!gameRunning || gamePaused) return;

            const now = Date.now();

            // Mover jugador
            if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed;
            if (keys['ArrowRight'] || keys['d']) player.x += player.speed;
            if (keys['ArrowUp'] || keys['w']) player.y -= player.speed;
            if (keys['ArrowDown'] || keys['s']) player.y += player.speed;

            // L√≠mites
            player.x = Math.max(30, Math.min(canvas.width - 30, player.x));
            player.y = Math.max(50, Math.min(canvas.height - 50, player.y));

            // Disparar
            if (keys[' ']) shoot();

            // Invulnerabilidad
            if (player.invulnerable && now > player.invulnerableTime) {
                player.invulnerable = false;
            }

            // Spawn enemigos usando configuraci√≥n de nivel
            const config = levelConfig[level];
            if (now - lastEnemySpawn > config.spawnDelay) {
                spawnEnemy();
                lastEnemySpawn = now;
            }

            // Spawn powerups
            if (now - lastPowerupSpawn > powerupSpawnDelay) {
                spawnPowerup();
                lastPowerupSpawn = now;
            }

            // Actualizar nubes
            updateClouds();

            // Actualizar balas
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                // Llamas tienen vida limitada
                if (bullet.type === 'flame') {
                    bullet.life--;
                    if (bullet.life <= 0) {
                        bullets.splice(i, 1);
                        continue;
                    }
                }

                // Misiles persiguen objetivo
                if (bullet.type === 'missile' && bullet.target && enemies.includes(bullet.target)) {
                    const dx = bullet.target.x - bullet.x;
                    const dy = bullet.target.y - bullet.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 0) {
                        bullet.vx += (dx / dist) * 0.5;
                        bullet.vy += (dy / dist) * 0.5;
                        const speed = Math.hypot(bullet.vx, bullet.vy);
                        if (speed > 10) {
                            bullet.vx = (bullet.vx / speed) * 10;
                            bullet.vy = (bullet.vy / speed) * 10;
                        }
                    }
                }

                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                if (bullet.y < -20 || bullet.y > canvas.height + 20 ||
                    bullet.x < -20 || bullet.x > canvas.width + 20) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Colisi√≥n con enemigos
                let bulletHit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const type = pterosaurTypes[enemy.type];

                    if (Math.abs(bullet.x - enemy.x) < type.width/2 &&
                        Math.abs(bullet.y - enemy.y) < type.height/2) {

                        // Bomba explota y da√±a √°rea
                        if (bullet.type === 'bomb') {
                            createExplosion(bullet.x, bullet.y, 15);
                            playSound('explosion');
                            // Da√±ar todos los enemigos en el radio
                            for (let k = enemies.length - 1; k >= 0; k--) {
                                const e = enemies[k];
                                const dist = Math.hypot(e.x - bullet.x, e.y - bullet.y);
                                if (dist < bullet.explosionRadius) {
                                    e.health -= bullet.damage * (1 - dist / bullet.explosionRadius);
                                    if (e.health <= 0) {
                                        createExplosion(e.x, e.y, 8);
                                        score += pterosaurTypes[e.type].points * level;
                                        killCount++;
                                        levelKills++;
                                        if (e === boss) boss = null;
                                        enemies.splice(k, 1);
                                    }
                                }
                            }
                            bullets.splice(i, 1);
                            checkLevelProgress();
                            break;
                        }

                        enemy.health -= bullet.damage;

                        // Boss entra en rage cuando tiene poca vida
                        if (enemy.type === 'boss' && enemy.health < enemy.maxHealth * 0.3) {
                            enemy.state = 'rage';
                        }

                        // Plasma no se destruye al impactar
                        if (!bullet.piercing) {
                            bulletHit = true;
                        }

                        playSound('hit');

                        // Part√≠culas de impacto
                        for (let k = 0; k < 5; k++) {
                            particles.push({
                                x: bullet.x,
                                y: bullet.y,
                                vx: (Math.random() - 0.5) * 5,
                                vy: (Math.random() - 0.5) * 5,
                                life: 15,
                                maxLife: 15,
                                size: 3,
                                color: type.color
                            });
                        }

                        if (enemy.health <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.type === 'boss' ? 20 : 8);
                            playSound('explosion');
                            score += type.points * level;
                            killCount++;
                            levelKills++;
                            if (enemy === boss) boss = null;
                            enemies.splice(j, 1);
                            checkLevelProgress();
                        }

                        if (bulletHit) break;
                    }
                }
                if (bulletHit) {
                    bullets.splice(i, 1);
                }
            }

            // Funci√≥n para verificar progreso de nivel
            function checkLevelProgress() {
                const config = levelConfig[level];
                if (levelKills >= config.kills && level < 7) {
                    levelUp();
                } else if (level === 7 && !boss && levelKills >= 1) {
                    victory();
                }
            }

            // Actualizar enemigos
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Movimiento seg√∫n patr√≥n
                switch(enemy.pattern) {
                    case 'straight':
                        enemy.y += enemy.speed;
                        break;
                    case 'zigzag':
                        enemy.y += enemy.speed;
                        enemy.x += Math.sin(enemy.y / 30 + enemy.phase) * 3;
                        break;
                    case 'dive':
                        enemy.y += enemy.speed;
                        if (enemy.y > canvas.height / 3) {
                            const dx = player.x - enemy.x;
                            enemy.x += dx * 0.02;
                            enemy.speed = Math.min(enemy.speed + 0.05, 6);
                        }
                        break;
                    case 'swoop':
                        enemy.phase += 0.03;
                        enemy.x += Math.sin(enemy.phase) * 4;
                        enemy.y += enemy.speed;
                        break;
                    case 'boss':
                        // Boss entra desde arriba
                        if (enemy.state === 'entering') {
                            enemy.y += 1;
                            if (enemy.y >= 120) {
                                enemy.state = 'fighting';
                            }
                        } else {
                            // Movimiento lateral
                            enemy.phase += enemy.state === 'rage' ? 0.04 : 0.02;
                            enemy.x = canvas.width / 2 + Math.sin(enemy.phase) * 200;

                            // Boss ataca peri√≥dicamente
                            enemy.attackTimer++;
                            const attackInterval = enemy.state === 'rage' ? 60 : 120;
                            if (enemy.attackTimer >= attackInterval) {
                                enemy.attackTimer = 0;
                                bossAttack(enemy);
                            }
                        }
                        break;
                }

                // L√≠mites laterales
                enemy.x = Math.max(30, Math.min(canvas.width - 30, enemy.x));

                // Fuera de pantalla
                if (enemy.y > canvas.height + 50) {
                    enemies.splice(i, 1);
                    continue;
                }

                // Colisi√≥n con jugador
                if (!player.invulnerable) {
                    const type = pterosaurTypes[enemy.type];
                    if (Math.abs(enemy.x - player.x) < (type.width/2 + 20) &&
                        Math.abs(enemy.y - player.y) < (type.height/2 + 25)) {

                        player.health -= 25;
                        player.invulnerable = true;
                        player.invulnerableTime = now + 2000;
                        playSound('damage');
                        createExplosion(player.x, player.y, 5);

                        if (player.health <= 0) {
                            gameOver();
                            return;
                        }

                        updateHUD();
                    }
                }
            }

            // Actualizar powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.y += powerup.speed;

                if (powerup.y > canvas.height + 50) {
                    powerups.splice(i, 1);
                    continue;
                }

                // Colisi√≥n con jugador
                if (Math.abs(powerup.x - player.x) < 35 &&
                    Math.abs(powerup.y - player.y) < 40) {

                    playSound('powerup');

                    if (powerup.type === 'health') {
                        player.health = Math.min(player.maxHealth, player.health + 30);
                    } else if (powerup.type === 'weapon') {
                        player.weapon = powerup.weaponType;
                        player.weaponLevel = Math.min(player.weaponLevel + 1, 3);
                    }

                    powerups.splice(i, 1);
                    updateHUD();
                }
            }

            // Actualizar part√≠culas
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx || 0;
                p.y += p.vy || 0;
                p.life--;

                // Actualizar rotaci√≥n para escombros
                if (p.rotation !== undefined && p.rotationSpeed) {
                    p.rotation += p.rotationSpeed;
                }

                // Agregar gravedad a escombros
                if (p.type === 'debris') {
                    p.vy += 0.2;
                }

                // Desacelerar humo
                if (p.type === 'smoke') {
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                }

                // Desacelerar fuego
                if (p.type === 'fire') {
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                }

                // Part√≠culas da√±inas del boss
                if (p.damaging && !player.invulnerable) {
                    if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y) < 30) {
                        player.health -= 15;
                        player.invulnerable = true;
                        player.invulnerableTime = now + 1500;
                        playSound('damage');
                        createExplosion(player.x, player.y, 5);
                        particles.splice(i, 1);

                        if (player.health <= 0) {
                            gameOver();
                            return;
                        }
                        updateHUD();
                        continue;
                    }
                }

                if (p.life <= 0 || p.y > canvas.height + 50 || p.y < -50 || p.x < -50 || p.x > canvas.width + 50) {
                    particles.splice(i, 1);
                }
            }
        }

        // ===== ATAQUE DEL BOSS =====
        function bossAttack(bossEnemy) {
            const rage = bossEnemy.state === 'rage';

            // Lanza pterosaurios peque√±os
            if (rage) {
                // En rage, dispara en abanico
                for (let angle = -40; angle <= 40; angle += 20) {
                    const rad = (angle + 90) * Math.PI / 180;
                    particles.push({
                        x: bossEnemy.x,
                        y: bossEnemy.y + 50,
                        vx: Math.cos(rad) * 6,
                        vy: Math.sin(rad) * 6,
                        life: 60,
                        maxLife: 60,
                        size: 8,
                        color: '#ff0000',
                        damaging: true
                    });
                }
            } else {
                // Normal: dispara hacia el jugador
                const dx = player.x - bossEnemy.x;
                const dy = player.y - bossEnemy.y;
                const dist = Math.hypot(dx, dy);
                particles.push({
                    x: bossEnemy.x,
                    y: bossEnemy.y + 50,
                    vx: (dx / dist) * 5,
                    vy: (dy / dist) * 5,
                    life: 80,
                    maxLife: 80,
                    size: 10,
                    color: '#ff4400',
                    damaging: true
                });
            }
            playSound('missile');
        }

        // ===== SUBIR DE NIVEL =====
        function levelUp() {
            if (level >= 7) return; // Ya en nivel m√°ximo

            level++;
            levelKills = 0; // Reset kills del nivel
            playSound('levelup');

            const config = levelConfig[level];
            const popup = document.getElementById('levelPopup');
            popup.innerHTML = '¬°NIVEL ' + level + '!<br><span style="font-size: 12px; color: #ffaa00;">' + config.name + '</span>';
            popup.style.display = 'block';

            setTimeout(() => {
                popup.style.display = 'none';
            }, 3000);

            updateHUD();
        }

        // ===== DIBUJAR =====
        function draw() {
            // Fondo
            drawBackground();

            // Part√≠culas mejoradas (detr√°s de todo)
            for (const p of particles) {
                ctx.save();
                const lifeRatio = p.life / p.maxLife;

                switch(p.type) {
                    case 'shockwave':
                        // Onda expansiva
                        const currentSize = p.maxSize * (1 - lifeRatio);
                        ctx.strokeStyle = `rgba(255, 200, 100, ${lifeRatio * 0.8})`;
                        ctx.lineWidth = 4 * lifeRatio;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
                        ctx.stroke();
                        // Segunda onda m√°s peque√±a
                        ctx.strokeStyle = `rgba(255, 255, 200, ${lifeRatio * 0.5})`;
                        ctx.lineWidth = 2 * lifeRatio;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, currentSize * 0.7, 0, Math.PI * 2);
                        ctx.stroke();
                        break;

                    case 'flash':
                        // Flash brillante
                        const flashGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * lifeRatio);
                        flashGrad.addColorStop(0, `rgba(255, 255, 255, ${lifeRatio})`);
                        flashGrad.addColorStop(0.3, `rgba(255, 255, 200, ${lifeRatio * 0.8})`);
                        flashGrad.addColorStop(0.6, `rgba(255, 200, 100, ${lifeRatio * 0.5})`);
                        flashGrad.addColorStop(1, 'rgba(255, 100, 0, 0)');
                        ctx.fillStyle = flashGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * (2 - lifeRatio), 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'fire':
                        // Part√≠cula de fuego con brillo
                        ctx.globalAlpha = lifeRatio;
                        const fireGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                        fireGrad.addColorStop(0, '#ffffff');
                        fireGrad.addColorStop(0.3, p.color);
                        fireGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = fireGrad;
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * (0.5 + lifeRatio * 0.5), 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'spark':
                        // Chispa con estela
                        ctx.globalAlpha = lifeRatio;
                        // Estela
                        ctx.strokeStyle = p.color;
                        ctx.lineWidth = p.size * 0.5;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x - p.vx * 2, p.y - p.vy * 2);
                        ctx.stroke();
                        // Punto brillante
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = 5;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'smoke':
                        // Humo con degradado
                        ctx.globalAlpha = lifeRatio * 0.6;
                        const smokeGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * (2 - lifeRatio));
                        smokeGrad.addColorStop(0, `rgba(80, 80, 80, ${lifeRatio * 0.5})`);
                        smokeGrad.addColorStop(0.5, `rgba(50, 50, 50, ${lifeRatio * 0.3})`);
                        smokeGrad.addColorStop(1, 'rgba(30, 30, 30, 0)');
                        ctx.fillStyle = smokeGrad;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * (2 - lifeRatio), 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'debris':
                        // Escombros giratorios
                        ctx.globalAlpha = lifeRatio;
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation || 0);
                        ctx.fillStyle = p.color;
                        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size * 0.6);
                        // Brillo
                        ctx.fillStyle = `rgba(255, 255, 200, ${lifeRatio * 0.3})`;
                        ctx.fillRect(-p.size/2, -p.size/2, p.size * 0.3, p.size * 0.3);
                        break;

                    default:
                        // Part√≠cula gen√©rica (para part√≠culas da√±inas del boss, etc.)
                        ctx.globalAlpha = lifeRatio;
                        if (p.damaging) {
                            // Part√≠culas del boss
                            const bossGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                            bossGrad.addColorStop(0, '#ffffff');
                            bossGrad.addColorStop(0.3, p.color);
                            bossGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                            ctx.fillStyle = bossGrad;
                            ctx.shadowColor = p.color;
                            ctx.shadowBlur = 15;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                            // Aura de peligro
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size + 3, 0, Math.PI * 2);
                            ctx.stroke();
                        } else {
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                }
                ctx.restore();
            }
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Powerups
            for (const powerup of powerups) {
                if (powerup.type === 'health') {
                    drawHealthEgg(powerup);
                } else {
                    drawWeaponPowerup(powerup);
                }
            }

            // Balas
            for (const bullet of bullets) {
                drawBullet(bullet);
            }

            // Enemigos
            for (const enemy of enemies) {
                if (enemy.type === 'boss') {
                    drawBoss(enemy);
                } else {
                    drawPterosaurus(enemy);
                }
            }

            // Jugador
            drawPlayer();
        }

        // ===== ACTUALIZAR HUD =====
        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = score;
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('weaponDisplay').textContent = weapons[player.weapon].name;
            const config = levelConfig[level];
            document.getElementById('levelDisplay').innerHTML = level + '<br><span style="font-size:6px;color:#aaa;">' + config.name.substring(0, 10) + '</span>';
        }

        // ===== GAME OVER =====
        function gameOver() {
            gameRunning = false;
            playSound('gameover');

            document.getElementById('finalScore').textContent = score;
            document.getElementById('killCount').textContent = killCount;
            document.getElementById('gameOverScreen').style.display = 'block';
        }

        // ===== VICTORIA =====
        function victory() {
            gameRunning = false;
            playSound('levelup');

            document.getElementById('victoryScore').textContent = score;
            document.getElementById('victoryKills').textContent = killCount;
            document.getElementById('victoryScreen').style.display = 'block';
        }

        // ===== INICIAR JUEGO =====
        function startGame() {
            initAudio();

            // Reset estado
            player = {
                x: canvas.width / 2,
                y: canvas.height - 80,
                width: 50,
                height: 60,
                speed: 6,
                health: 100,
                maxHealth: 100,
                weapon: 'machinegun',
                weaponLevel: 1,
                invulnerable: false,
                invulnerableTime: 0
            };

            bullets = [];
            enemies = [];
            powerups = [];
            particles = [];
            clouds = [];
            boss = null;

            score = 0;
            level = 1;
            killCount = 0;
            levelKills = 0;
            difficultyMultiplier = 1;

            lastShot = 0;
            lastEnemySpawn = 0;
            lastPowerupSpawn = 0;

            updateHUD();

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';

            gameRunning = true;
            gamePaused = false;
        }

        // ===== GAME LOOP =====
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // ===== CONTROLES =====
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === 'p' || e.key === 'P') {
                if (gameRunning) {
                    gamePaused = !gamePaused;
                    document.getElementById('pausedOverlay').style.display = gamePaused ? 'block' : 'none';
                }
            }

            if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Iniciar loop
        gameLoop();
    </script>
</body>
</html>
