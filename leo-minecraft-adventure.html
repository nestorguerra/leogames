<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Aventura de Leo - Estilo Minecraft</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            background: #000;
            border: 6px solid #8B4513;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(139, 69, 19, 0.5);
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        #startScreen, #gameOverScreen, #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10;
        }

        #gameOverScreen, #victoryScreen {
            display: none;
        }

        h1 {
            color: #4ade80;
            font-size: 28px;
            text-shadow: 4px 4px #166534;
            margin-bottom: 20px;
            text-align: center;
        }

        h2 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 30px;
            text-align: center;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 10px;
            margin-bottom: 30px;
        }

        .btn {
            background: linear-gradient(180deg, #4ade80 0%, #22c55e 100%);
            border: 4px solid #166534;
            color: #000;
            padding: 15px 40px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.6);
        }

        .instructions {
            color: #94a3b8;
            font-size: 8px;
            text-align: center;
            margin-top: 30px;
            line-height: 2.5;
        }

        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: none;
            justify-content: space-between;
            z-index: 5;
            pointer-events: none;
        }

        .hud-box {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #4ade80;
            padding: 8px 15px;
            color: #fff;
            font-size: 10px;
        }

        .hud-box span {
            color: #4ade80;
        }

        #victoryScreen h1 {
            color: #fbbf24;
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        #gameOverScreen h1 {
            color: #ef4444;
        }

        .score-text {
            color: #fbbf24;
            font-size: 14px;
            margin: 20px 0;
        }

        /* Mini mapa */
        #minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            border: 3px solid #4ade80;
            background: rgba(0,0,0,0.7);
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="hud">
            <div class="hud-box">‚ù§Ô∏è VIDAS: <span id="lives">3</span></div>
            <div class="hud-box">üíé <span id="coins">0</span></div>
            <div class="hud-box">üó°Ô∏è ESQUELETOS: <span id="kills">0</span></div>
        </div>

        <canvas id="minimap" width="150" height="200"></canvas>

        <div id="startScreen">
            <h1>LA AVENTURA<br>DE LEO</h1>
            <h2>‚õèÔ∏è Estilo Minecraft ‚õèÔ∏è</h2>
            <div class="subtitle">Dise√±ado por Leo</div>
            <button class="btn" onclick="startGame()">‚ñ∂ JUGAR</button>
            <div class="instructions">
                ‚Üê ‚Üí ‚Üë ‚Üì √≥ WASD = MOVER<br>
                ESPACIO = ATACAR ESQUELETOS<br>
                ¬°LLEGA AL TESORO DEL FONDO!
            </div>
        </div>

        <div id="gameOverScreen">
            <h1>üíÄ GAME OVER üíÄ</h1>
            <div class="score-text">Los esqueletos te atraparon</div>
            <button class="btn" onclick="restartGame()">üîÑ REINTENTAR</button>
        </div>

        <div id="victoryScreen">
            <h1>üèÜ ¬°VICTORIA! üèÜ</h1>
            <div class="score-text">¬°Leo encontr√≥ el tesoro!</div>
            <div class="score-text">Monedas: <span id="finalCoins">0</span></div>
            <div class="score-text">Esqueletos derrotados: <span id="finalKills">0</span></div>
            <button class="btn" onclick="restartGame()">üéÆ JUGAR DE NUEVO</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Tama√±o del mundo (m√°s grande que la pantalla)
        const WORLD_WIDTH = 1600;
        const WORLD_HEIGHT = 2400;
        const TILE_SIZE = 32;

        // Estado del juego
        let gameState = 'menu';
        let lives = 3;
        let coins = 0;
        let kills = 0;

        // C√°mara
        let camera = { x: 0, y: 0 };

        // Audio
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            switch(type) {
                case 'coin':
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(1108, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'hit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'attack':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime + 0.05);
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'victory':
                    osc.type = 'square';
                    [523, 659, 784, 1047].forEach((f, i) => {
                        osc.frequency.setValueAtTime(f, audioCtx.currentTime + i * 0.15);
                    });
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.7);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.7);
                    break;
            }
        }

        // Jugador (estilo Minecraft como el dibujo de Leo)
        const player = {
            x: 750,
            y: 150,
            width: 28,
            height: 48,
            speed: 4,
            facing: 'down',
            frame: 0,
            attacking: false,
            attackTimer: 0,
            invincible: false,
            invincibleTimer: 0
        };

        // Mapa basado en el dibujo de Leo
        // 0 = pasto, 1 = agua, 2 = camino, 3 = muro/roca, 4 = templo, 5 = ruinas
        const mapData = [];
        const mapWidth = Math.floor(WORLD_WIDTH / TILE_SIZE);
        const mapHeight = Math.floor(WORLD_HEIGHT / TILE_SIZE);

        // Generar mapa inspirado en el dibujo de Leo
        function generateMap() {
            // Inicializar todo como pasto
            for (let y = 0; y < mapHeight; y++) {
                mapData[y] = [];
                for (let x = 0; x < mapWidth; x++) {
                    mapData[y][x] = 0; // pasto
                }
            }

            // Agua en los bordes y algunas √°reas (como la isla del dibujo)
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    // Bordes
                    if (x < 2 || x >= mapWidth - 2 || y < 2 || y >= mapHeight - 2) {
                        mapData[y][x] = 1; // agua
                    }
                }
            }

            // Isla a la derecha (como en el dibujo)
            for (let y = 50; y < 65; y++) {
                for (let x = 38; x < 48; x++) {
                    if (x < mapWidth && y < mapHeight) {
                        mapData[y][x] = 1; // agua alrededor
                    }
                }
            }
            for (let y = 52; y < 63; y++) {
                for (let x = 40; x < 46; x++) {
                    if (x < mapWidth && y < mapHeight) {
                        mapData[y][x] = 0; // isla de tierra
                    }
                }
            }

            // Camino serpenteante desde arriba hasta el tesoro (como el dibujo)
            const pathPoints = [
                {x: 24, y: 5}, {x: 24, y: 10}, {x: 28, y: 15}, {x: 32, y: 20},
                {x: 35, y: 25}, {x: 35, y: 30}, {x: 30, y: 35}, {x: 25, y: 40},
                {x: 20, y: 45}, {x: 18, y: 50}, {x: 20, y: 55}, {x: 25, y: 60},
                {x: 25, y: 65}, {x: 22, y: 70}
            ];

            // Dibujar camino
            for (let i = 0; i < pathPoints.length - 1; i++) {
                const p1 = pathPoints[i];
                const p2 = pathPoints[i + 1];
                drawPath(p1.x, p1.y, p2.x, p2.y);
            }

            // Estructuras del mapa (templos como en el dibujo)
            // Templo superior con entrada (cofre del dibujo)
            drawStructure(20, 3, 10, 6, 4);

            // Ruinas escalonadas (edificio con escaleras del dibujo)
            drawStructure(8, 25, 8, 8, 5);

            // Templo circular (el "tem" del dibujo)
            drawCircularTemple(12, 45, 5);

            // Templo derecho ("temptes" del dibujo)
            drawStructure(35, 15, 6, 5, 4);

            // Rocas y obst√°culos aleatorios
            for (let i = 0; i < 40; i++) {
                const rx = 5 + Math.floor(Math.random() * (mapWidth - 10));
                const ry = 10 + Math.floor(Math.random() * (mapHeight - 15));
                if (mapData[ry] && mapData[ry][rx] === 0) {
                    mapData[ry][rx] = 3;
                }
            }
        }

        function drawPath(x1, y1, x2, y2) {
            const steps = Math.max(Math.abs(x2 - x1), Math.abs(y2 - y1));
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(x1 + (x2 - x1) * i / steps);
                const y = Math.round(y1 + (y2 - y1) * i / steps);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (mapData[y + dy] && mapData[y + dy][x + dx] !== undefined) {
                            mapData[y + dy][x + dx] = 2;
                        }
                    }
                }
            }
        }

        function drawStructure(sx, sy, w, h, type) {
            for (let y = sy; y < sy + h; y++) {
                for (let x = sx; x < sx + w; x++) {
                    if (mapData[y] && mapData[y][x] !== undefined) {
                        // Bordes son muros
                        if (x === sx || x === sx + w - 1 || y === sy || y === sy + h - 1) {
                            mapData[y][x] = 3;
                        } else {
                            mapData[y][x] = type;
                        }
                    }
                }
            }
            // Entrada
            if (mapData[sy + h - 1]) {
                mapData[sy + h - 1][sx + Math.floor(w/2)] = 2;
                mapData[sy + h - 1][sx + Math.floor(w/2) + 1] = 2;
            }
        }

        function drawCircularTemple(cx, cy, r) {
            for (let y = cy - r; y <= cy + r; y++) {
                for (let x = cx - r; x <= cx + r; x++) {
                    const dist = Math.sqrt((x - cx) ** 2 + (y - cy) ** 2);
                    if (mapData[y] && mapData[y][x] !== undefined) {
                        if (dist <= r && dist >= r - 1) {
                            mapData[y][x] = 3;
                        } else if (dist < r - 1) {
                            mapData[y][x] = 4;
                        }
                    }
                }
            }
            // Entrada
            if (mapData[cy + r]) {
                mapData[cy + r][cx] = 2;
            }
        }

        // Objetos del juego
        let coinItems = [];
        let skeletons = [];
        let particles = [];

        // Tesoro final (al fondo del mapa como en el dibujo)
        const treasure = {
            x: 22 * TILE_SIZE,
            y: 70 * TILE_SIZE,
            width: 48,
            height: 40,
            collected: false
        };

        function generateCoins() {
            coinItems = [];
            const positions = [
                {x: 24, y: 8}, {x: 30, y: 18}, {x: 35, y: 28},
                {x: 25, y: 38}, {x: 18, y: 48}, {x: 22, y: 58},
                {x: 10, y: 30}, {x: 38, y: 20}, {x: 15, y: 50},
                {x: 42, y: 55}, {x: 30, y: 45}, {x: 12, y: 35}
            ];
            positions.forEach(p => {
                coinItems.push({
                    x: p.x * TILE_SIZE + 8,
                    y: p.y * TILE_SIZE + 8,
                    collected: false,
                    frame: Math.random() * Math.PI * 2
                });
            });
        }

        function generateSkeletons() {
            skeletons = [];
            const positions = [
                {x: 26, y: 15, patrol: 'horizontal'},
                {x: 33, y: 25, patrol: 'vertical'},
                {x: 22, y: 35, patrol: 'horizontal'},
                {x: 15, y: 45, patrol: 'vertical'},
                {x: 28, y: 55, patrol: 'horizontal'},
                {x: 18, y: 60, patrol: 'vertical'},
                {x: 10, y: 28, patrol: 'horizontal'},
                {x: 38, y: 18, patrol: 'vertical'},
                {x: 20, y: 68, patrol: 'horizontal'}
            ];
            positions.forEach(p => {
                skeletons.push({
                    x: p.x * TILE_SIZE,
                    y: p.y * TILE_SIZE,
                    startX: p.x * TILE_SIZE,
                    startY: p.y * TILE_SIZE,
                    width: 28,
                    height: 44,
                    speed: 1.5,
                    patrol: p.patrol,
                    direction: 1,
                    frame: 0,
                    health: 2
                });
            });
        }

        // Controles
        const keys = {};
        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space' && gameState === 'playing' && !player.attacking) {
                player.attacking = true;
                player.attackTimer = 15;
                playSound('attack');
            }
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        // ==================== DIBUJAR PERSONAJE DE LEO ====================
        function drawPlayer(screenX, screenY) {
            if (player.invincible && Math.floor(Date.now() / 80) % 2 === 0) return;

            ctx.save();
            ctx.translate(screenX, screenY);

            const bounce = Math.sin(player.frame * 0.3) * 2;

            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 24, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // CUERPO (largo y delgado como el dibujo)
            ctx.fillStyle = '#3b82f6'; // azul
            ctx.fillRect(-8, -5 + bounce, 16, 28);

            // Detalle del cuerpo
            ctx.fillStyle = '#2563eb';
            ctx.fillRect(-8, -5 + bounce, 3, 28);
            ctx.fillRect(5, -5 + bounce, 3, 28);

            // Cintur√≥n (como en el dibujo)
            ctx.fillStyle = '#854d0e';
            ctx.fillRect(-9, 8 + bounce, 18, 4);
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(-2, 8 + bounce, 4, 4);

            // CABEZA (rectangular/cuadrada estilo Minecraft como el dibujo)
            ctx.fillStyle = '#fcd9b6';
            ctx.fillRect(-12, -28 + bounce, 24, 22);

            // Pelo/Cabello (parte superior como el dibujo)
            ctx.fillStyle = '#78350f';
            ctx.fillRect(-12, -28 + bounce, 24, 6);
            ctx.fillRect(-12, -28 + bounce, 4, 10);
            ctx.fillRect(8, -28 + bounce, 4, 10);

            // OJOS (cuadrados como en el dibujo de Leo)
            ctx.fillStyle = '#000';
            ctx.fillRect(-8, -20 + bounce, 5, 5);
            ctx.fillRect(3, -20 + bounce, 5, 5);

            // Brillo de ojos
            ctx.fillStyle = '#fff';
            ctx.fillRect(-7, -19 + bounce, 2, 2);
            ctx.fillRect(4, -19 + bounce, 2, 2);

            // BOCA (peque√±a l√≠nea como el dibujo)
            ctx.fillStyle = '#000';
            ctx.fillRect(-4, -11 + bounce, 8, 2);

            // PIERNAS
            ctx.fillStyle = '#1e40af';
            ctx.fillRect(-7, 23 + bounce, 6, 12);
            ctx.fillRect(1, 23 + bounce, 6, 12);

            // Pies
            ctx.fillStyle = '#374151';
            ctx.fillRect(-8, 33 + bounce, 7, 4);
            ctx.fillRect(1, 33 + bounce, 7, 4);

            // BRAZOS
            ctx.fillStyle = '#3b82f6';
            const armSwing = Math.sin(player.frame * 0.3) * 5;

            // Brazo izquierdo
            ctx.save();
            ctx.translate(-10, 0 + bounce);
            ctx.rotate((-15 + armSwing) * Math.PI / 180);
            ctx.fillRect(-4, 0, 5, 16);
            ctx.fillStyle = '#fcd9b6';
            ctx.fillRect(-3, 14, 4, 5);
            ctx.restore();

            // Brazo derecho
            ctx.save();
            ctx.translate(10, 0 + bounce);
            if (player.attacking) {
                ctx.rotate(-60 * Math.PI / 180);
            } else {
                ctx.rotate((15 - armSwing) * Math.PI / 180);
            }
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(-1, 0, 5, 16);
            ctx.fillStyle = '#fcd9b6';
            ctx.fillRect(0, 14, 4, 5);

            // Espada si est√° atacando
            if (player.attacking) {
                ctx.fillStyle = '#9ca3af';
                ctx.fillRect(0, 18, 3, 20);
                ctx.fillStyle = '#fbbf24';
                ctx.fillRect(-1, 16, 5, 4);
            }
            ctx.restore();

            ctx.restore();
        }

        // ==================== DIBUJAR ESQUELETO ====================
        function drawSkeleton(skeleton, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);

            const time = Date.now() / 150;
            const wobble = Math.sin(time + skeleton.startX) * 2;

            // Sombra
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 22, 10, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Piernas (huesos)
            ctx.fillStyle = '#e5e5e5';
            ctx.fillRect(-8, 10 + wobble, 4, 18);
            ctx.fillRect(4, 10 + wobble, 4, 18);

            // Pies
            ctx.fillRect(-10, 26 + wobble, 8, 3);
            ctx.fillRect(2, 26 + wobble, 8, 3);

            // Costillas
            ctx.fillStyle = '#d4d4d4';
            ctx.fillRect(-10, -8 + wobble, 20, 20);
            ctx.fillStyle = '#1a1a2e';
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(-8, -5 + i * 5 + wobble, 16, 2);
            }

            // Brazos (huesos)
            ctx.fillStyle = '#e5e5e5';
            ctx.fillRect(-16, -5 + wobble, 6, 3);
            ctx.fillRect(-18, -5 + wobble, 3, 15);
            ctx.fillRect(10, -5 + wobble, 6, 3);
            ctx.fillRect(15, -5 + wobble, 3, 15);

            // Cr√°neo
            ctx.fillStyle = '#f5f5f5';
            ctx.beginPath();
            ctx.arc(0, -18 + wobble, 12, 0, Math.PI * 2);
            ctx.fill();

            // Ojos (cuencas vac√≠as)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-5, -20 + wobble, 4, 5, 0, 0, Math.PI * 2);
            ctx.ellipse(5, -20 + wobble, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nariz
            ctx.fillRect(-2, -16 + wobble, 4, 5);

            // Dientes
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(-6, -10 + wobble, 12, 4);
            ctx.fillStyle = '#000';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(-5 + i * 3, -10 + wobble, 1, 4);
            }

            // Arco y flecha
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(20, 0 + wobble, 15, -Math.PI/2, Math.PI/2);
            ctx.stroke();

            // Cuerda
            ctx.strokeStyle = '#d4d4d4';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(20, -15 + wobble);
            ctx.lineTo(20, 15 + wobble);
            ctx.stroke();

            // Flecha
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(5, -2 + wobble, 20, 3);
            ctx.fillStyle = '#6b7280';
            ctx.beginPath();
            ctx.moveTo(5, 0 + wobble);
            ctx.lineTo(-3, -4 + wobble);
            ctx.lineTo(-3, 4 + wobble);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // ==================== DIBUJAR MAPA ====================
        function drawMap() {
            const startTileX = Math.floor(camera.x / TILE_SIZE);
            const startTileY = Math.floor(camera.y / TILE_SIZE);
            const endTileX = startTileX + Math.ceil(canvas.width / TILE_SIZE) + 1;
            const endTileY = startTileY + Math.ceil(canvas.height / TILE_SIZE) + 1;

            for (let y = startTileY; y < endTileY; y++) {
                for (let x = startTileX; x < endTileX; x++) {
                    if (y < 0 || y >= mapHeight || x < 0 || x >= mapWidth) continue;

                    const tile = mapData[y][x];
                    const screenX = x * TILE_SIZE - camera.x;
                    const screenY = y * TILE_SIZE - camera.y;

                    switch(tile) {
                        case 0: // Pasto
                            ctx.fillStyle = '#22c55e';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#16a34a';
                            // Detalle de pasto
                            for (let i = 0; i < 3; i++) {
                                const gx = screenX + 5 + i * 10 + (x * 7 + y * 3) % 5;
                                const gy = screenY + 10 + (x * 3 + y * 7) % 10;
                                ctx.fillRect(gx, gy, 2, 6);
                            }
                            break;
                        case 1: // Agua
                            ctx.fillStyle = '#0ea5e9';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#38bdf8';
                            const waveOffset = Math.sin(Date.now() / 300 + x + y) * 3;
                            ctx.fillRect(screenX + 5, screenY + 10 + waveOffset, 12, 3);
                            ctx.fillRect(screenX + 18, screenY + 20 - waveOffset, 10, 3);
                            break;
                        case 2: // Camino
                            ctx.fillStyle = '#d4a574';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#c49a6c';
                            ctx.fillRect(screenX + 5, screenY + 8, 4, 4);
                            ctx.fillRect(screenX + 20, screenY + 20, 5, 5);
                            break;
                        case 3: // Muro/Roca
                            ctx.fillStyle = '#6b7280';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#4b5563';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, 4);
                            ctx.fillRect(screenX, screenY, 4, TILE_SIZE);
                            ctx.fillStyle = '#9ca3af';
                            ctx.fillRect(screenX + 4, screenY + 4, 8, 8);
                            ctx.fillRect(screenX + 18, screenY + 16, 10, 10);
                            break;
                        case 4: // Templo
                            ctx.fillStyle = '#fef3c7';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#fcd34d';
                            ctx.fillRect(screenX + 4, screenY + 4, 24, 24);
                            ctx.fillStyle = '#f59e0b';
                            ctx.fillRect(screenX + 12, screenY + 8, 8, 16);
                            break;
                        case 5: // Ruinas
                            ctx.fillStyle = '#a8a29e';
                            ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#78716c';
                            ctx.fillRect(screenX + 2, screenY + 2, 8, 20);
                            ctx.fillRect(screenX + 22, screenY + 8, 8, 14);
                            ctx.fillRect(screenX + 10, screenY + 12, 12, 4);
                            break;
                    }

                    // Borde de tile para efecto pixel
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // ==================== DIBUJAR MONEDAS ====================
        function drawCoins() {
            coinItems.forEach(coin => {
                if (coin.collected) return;

                const screenX = coin.x - camera.x;
                const screenY = coin.y - camera.y;

                if (screenX < -20 || screenX > canvas.width + 20 ||
                    screenY < -20 || screenY > canvas.height + 20) return;

                coin.frame += 0.1;
                const scale = 0.8 + Math.sin(coin.frame) * 0.2;
                const floatY = Math.sin(coin.frame * 2) * 3;

                ctx.save();
                ctx.translate(screenX + 8, screenY + 8 + floatY);
                ctx.scale(scale, 1);

                // Brillo
                ctx.fillStyle = 'rgba(251, 191, 36, 0.4)';
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2);
                ctx.fill();

                // Moneda
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fbbf24';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('$', 0, 1);

                ctx.restore();
            });
        }

        // ==================== DIBUJAR TESORO ====================
        function drawTreasure() {
            if (treasure.collected) return;

            const screenX = treasure.x - camera.x;
            const screenY = treasure.y - camera.y;

            if (screenX < -50 || screenX > canvas.width + 50 ||
                screenY < -50 || screenY > canvas.height + 50) return;

            const time = Date.now() / 200;
            const float = Math.sin(time) * 5;

            ctx.save();
            ctx.translate(screenX + treasure.width/2, screenY + treasure.height/2 + float);

            // Aura brillante
            ctx.fillStyle = `rgba(251, 191, 36, ${0.3 + Math.sin(time * 2) * 0.2})`;
            ctx.beginPath();
            ctx.arc(0, 0, 50, 0, Math.PI * 2);
            ctx.fill();

            // Rayos de luz
            ctx.strokeStyle = `rgba(251, 191, 36, ${0.5 + Math.sin(time * 3) * 0.3})`;
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
                const angle = (time + i * Math.PI / 4);
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
                ctx.lineTo(Math.cos(angle) * 45, Math.sin(angle) * 45);
                ctx.stroke();
            }

            // Cofre base
            ctx.fillStyle = '#92400e';
            ctx.fillRect(-25, 0, 50, 25);

            // Tapa
            ctx.fillStyle = '#b45309';
            ctx.beginPath();
            ctx.moveTo(-27, 0);
            ctx.quadraticCurveTo(0, -20, 27, 0);
            ctx.lineTo(-27, 0);
            ctx.fill();

            // Bordes dorados
            ctx.fillStyle = '#fbbf24';
            ctx.fillRect(-27, -2, 54, 5);
            ctx.fillRect(-27, 20, 54, 5);
            ctx.fillRect(-27, -2, 5, 27);
            ctx.fillRect(22, -2, 5, 27);

            // Cerradura
            ctx.fillStyle = '#fbbf24';
            ctx.beginPath();
            ctx.arc(0, 12, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.fillRect(-2, 10, 4, 8);

            // Brillo
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.ellipse(-12, -8, 5, 3, -0.5, 0, Math.PI * 2);
            ctx.fill();

            // Part√≠culas de oro
            for (let i = 0; i < 6; i++) {
                const angle = (time * 0.5 + i * Math.PI / 3);
                const dist = 35 + Math.sin(time + i) * 5;
                const px = Math.cos(angle) * dist;
                const py = Math.sin(angle) * dist;
                ctx.fillStyle = `rgba(251, 191, 36, ${0.9 - i * 0.1})`;
                ctx.beginPath();
                ctx.arc(px, py, 4 - i * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // Texto "TESORO"
            ctx.fillStyle = '#fbbf24';
            ctx.font = '10px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('¬°TESORO!', screenX + treasure.width/2, screenY - 20 + float);
        }

        // ==================== PARTICULAS ====================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    life: 1,
                    color,
                    size: 3 + Math.random() * 4
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.15;
                p.life -= 0.025;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const screenX = p.x - camera.x;
                const screenY = p.y - camera.y;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(screenX - p.size/2, screenY - p.size/2, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }

        // ==================== MINIMAPA ====================
        function drawMinimap() {
            minimapCtx.fillStyle = '#1a1a2e';
            minimapCtx.fillRect(0, 0, 150, 200);

            const scaleX = 150 / WORLD_WIDTH;
            const scaleY = 200 / WORLD_HEIGHT;

            // Dibujar tiles simplificados
            for (let y = 0; y < mapHeight; y += 2) {
                for (let x = 0; x < mapWidth; x += 2) {
                    const tile = mapData[y][x];
                    switch(tile) {
                        case 0: minimapCtx.fillStyle = '#22c55e'; break;
                        case 1: minimapCtx.fillStyle = '#0ea5e9'; break;
                        case 2: minimapCtx.fillStyle = '#d4a574'; break;
                        case 3: minimapCtx.fillStyle = '#6b7280'; break;
                        case 4: minimapCtx.fillStyle = '#fcd34d'; break;
                        case 5: minimapCtx.fillStyle = '#a8a29e'; break;
                    }
                    minimapCtx.fillRect(x * TILE_SIZE * scaleX, y * TILE_SIZE * scaleY, 4, 4);
                }
            }

            // Tesoro
            minimapCtx.fillStyle = '#fbbf24';
            minimapCtx.fillRect(treasure.x * scaleX - 3, treasure.y * scaleY - 3, 8, 8);

            // Esqueletos
            minimapCtx.fillStyle = '#ef4444';
            skeletons.forEach(s => {
                minimapCtx.fillRect(s.x * scaleX - 1, s.y * scaleY - 1, 4, 4);
            });

            // Jugador
            minimapCtx.fillStyle = '#3b82f6';
            minimapCtx.fillRect(player.x * scaleX - 2, player.y * scaleY - 2, 6, 6);

            // Viewport
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scaleX,
                camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );
        }

        // ==================== LOGICA DEL JUEGO ====================
        function updatePlayer() {
            let moving = false;
            let dx = 0, dy = 0;

            if (keys['ArrowLeft'] || keys['KeyA']) { dx = -1; player.facing = 'left'; moving = true; }
            if (keys['ArrowRight'] || keys['KeyD']) { dx = 1; player.facing = 'right'; moving = true; }
            if (keys['ArrowUp'] || keys['KeyW']) { dy = -1; player.facing = 'up'; moving = true; }
            if (keys['ArrowDown'] || keys['KeyS']) { dy = 1; player.facing = 'down'; moving = true; }

            // Normalizar diagonal
            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            const newX = player.x + dx * player.speed;
            const newY = player.y + dy * player.speed;

            // Colisi√≥n con mapa
            if (!checkCollision(newX, player.y)) player.x = newX;
            if (!checkCollision(player.x, newY)) player.y = newY;

            // L√≠mites del mundo
            player.x = Math.max(20, Math.min(WORLD_WIDTH - 20, player.x));
            player.y = Math.max(20, Math.min(WORLD_HEIGHT - 20, player.y));

            // Animaci√≥n
            if (moving) player.frame++;

            // Timer de ataque
            if (player.attacking) {
                player.attackTimer--;
                if (player.attackTimer <= 0) player.attacking = false;
            }

            // Timer de invencibilidad
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) player.invincible = false;
            }

            // Actualizar c√°mara
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
            camera.x = Math.max(0, Math.min(WORLD_WIDTH - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD_HEIGHT - canvas.height, camera.y));
        }

        function checkCollision(x, y) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);

            // Verificar tiles alrededor
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = tileX + dx;
                    const checkY = tileY + dy;
                    if (checkY >= 0 && checkY < mapHeight && checkX >= 0 && checkX < mapWidth) {
                        const tile = mapData[checkY][checkX];
                        if (tile === 1 || tile === 3) { // agua o muro
                            const tileLeft = checkX * TILE_SIZE;
                            const tileTop = checkY * TILE_SIZE;
                            const tileRight = tileLeft + TILE_SIZE;
                            const tileBottom = tileTop + TILE_SIZE;

                            if (x + 10 > tileLeft && x - 10 < tileRight &&
                                y + 20 > tileTop && y - 20 < tileBottom) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function updateSkeletons() {
            skeletons.forEach(skeleton => {
                // Patrulla
                if (skeleton.patrol === 'horizontal') {
                    skeleton.x += skeleton.speed * skeleton.direction;
                    if (skeleton.x > skeleton.startX + 80 || skeleton.x < skeleton.startX - 80) {
                        skeleton.direction *= -1;
                    }
                } else {
                    skeleton.y += skeleton.speed * skeleton.direction;
                    if (skeleton.y > skeleton.startY + 80 || skeleton.y < skeleton.startY - 80) {
                        skeleton.direction *= -1;
                    }
                }

                skeleton.frame++;

                // Colisi√≥n con jugador
                const dx = player.x - skeleton.x;
                const dy = player.y - skeleton.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 30) {
                    if (player.attacking) {
                        skeleton.health--;
                        createParticles(skeleton.x, skeleton.y, '#e5e5e5', 10);
                        playSound('hit');

                        if (skeleton.health <= 0) {
                            skeletons = skeletons.filter(s => s !== skeleton);
                            kills++;
                            createParticles(skeleton.x, skeleton.y, '#f5f5f5', 20);
                            updateHUD();
                        }
                    } else if (!player.invincible) {
                        playerHit();
                    }
                }
            });
        }

        function playerHit() {
            lives--;
            playSound('hit');
            createParticles(player.x, player.y, '#ef4444', 15);
            player.invincible = true;
            player.invincibleTimer = 90;
            updateHUD();

            if (lives <= 0) {
                gameState = 'gameover';
                document.getElementById('gameOverScreen').style.display = 'flex';
            }
        }

        function checkCollectibles() {
            // Monedas
            coinItems.forEach(coin => {
                if (coin.collected) return;
                const dx = player.x - coin.x - 8;
                const dy = player.y - coin.y - 8;
                if (Math.sqrt(dx*dx + dy*dy) < 25) {
                    coin.collected = true;
                    coins++;
                    playSound('coin');
                    createParticles(coin.x + 8, coin.y + 8, '#fbbf24', 8);
                    updateHUD();
                }
            });

            // Tesoro
            if (!treasure.collected) {
                const dx = player.x - treasure.x - treasure.width/2;
                const dy = player.y - treasure.y - treasure.height/2;
                if (Math.sqrt(dx*dx + dy*dy) < 40) {
                    treasure.collected = true;
                    playSound('victory');
                    createParticles(treasure.x + treasure.width/2, treasure.y + treasure.height/2, '#fbbf24', 40);

                    setTimeout(() => {
                        gameState = 'victory';
                        document.getElementById('finalCoins').textContent = coins;
                        document.getElementById('finalKills').textContent = kills;
                        document.getElementById('victoryScreen').style.display = 'flex';
                    }, 1000);
                }
            }
        }

        function updateHUD() {
            document.getElementById('lives').textContent = lives;
            document.getElementById('coins').textContent = coins;
            document.getElementById('kills').textContent = kills;
        }

        // ==================== GAME LOOP ====================
        function gameLoop() {
            if (gameState !== 'playing') return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Actualizar
            updatePlayer();
            updateSkeletons();
            checkCollectibles();
            updateParticles();

            // Dibujar
            drawMap();
            drawCoins();
            drawTreasure();

            // Esqueletos
            skeletons.forEach(s => {
                const screenX = s.x - camera.x;
                const screenY = s.y - camera.y;
                if (screenX > -50 && screenX < canvas.width + 50 &&
                    screenY > -50 && screenY < canvas.height + 50) {
                    drawSkeleton(s, screenX, screenY);
                }
            });

            // Jugador
            drawPlayer(player.x - camera.x, player.y - camera.y);

            drawParticles();
            drawMinimap();

            requestAnimationFrame(gameLoop);
        }

        // ==================== INICIAR JUEGO ====================
        function startGame() {
            initAudio();
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            document.getElementById('minimap').style.display = 'block';

            generateMap();
            generateCoins();
            generateSkeletons();

            player.x = 750;
            player.y = 150;
            lives = 3;
            coins = 0;
            kills = 0;
            treasure.collected = false;

            updateHUD();
            gameState = 'playing';
            gameLoop();
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            gameState = 'menu';
        }
    </script>
</body>
</html>
